'use strict';

import _regeneratorRuntime from 'babel-runtime/regenerator';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fs = require('fs');
var sysPath = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var fsevents = void 0;
try {
  fsevents = require('fsevents');
} catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  var mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    var maj = Number.parseInt(mtch[1], 10);
    var min = Number.parseInt(mtch[2], 10);
    if (maj === 8 && min < 16) {
      fsevents = undefined;
    }
  }
}

var _require2 = require('./constants'),
    EV_ADD = _require2.EV_ADD,
    EV_CHANGE = _require2.EV_CHANGE,
    EV_ADD_DIR = _require2.EV_ADD_DIR,
    EV_UNLINK = _require2.EV_UNLINK,
    EV_ERROR = _require2.EV_ERROR,
    STR_DATA = _require2.STR_DATA,
    STR_END = _require2.STR_END,
    FSEVENT_CREATED = _require2.FSEVENT_CREATED,
    FSEVENT_MODIFIED = _require2.FSEVENT_MODIFIED,
    FSEVENT_DELETED = _require2.FSEVENT_DELETED,
    FSEVENT_MOVED = _require2.FSEVENT_MOVED,
    FSEVENT_UNKNOWN = _require2.FSEVENT_UNKNOWN,
    FSEVENT_TYPE_FILE = _require2.FSEVENT_TYPE_FILE,
    FSEVENT_TYPE_DIRECTORY = _require2.FSEVENT_TYPE_DIRECTORY,
    FSEVENT_TYPE_SYMLINK = _require2.FSEVENT_TYPE_SYMLINK,
    ROOT_GLOBSTAR = _require2.ROOT_GLOBSTAR,
    DIR_SUFFIX = _require2.DIR_SUFFIX,
    DOT_SLASH = _require2.DOT_SLASH,
    FUNCTION_TYPE = _require2.FUNCTION_TYPE,
    EMPTY_FN = _require2.EMPTY_FN,
    IDENTITY_FN = _require2.IDENTITY_FN;

var Depth = function Depth(value) {
  return isNaN(value) ? {} : { depth: value };
};

var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
var realpath = promisify(fs.realpath);

var statMethods = { stat: stat, lstat: lstat };

/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */

// fsevents instance helper functions
/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */
var FSEventsWatchers = new Map();

// Threshold of duplicate path prefixes at which to start
// consolidating going forward
var consolidateThreshhold = 10;

var wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);

/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */
var createFSEventsInstance = function createFSEventsInstance(path, callback) {
  var stop = fsevents.watch(path, callback);
  return { stop: stop };
};

/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */
function setFSEventsListener(path, realPath, listener, rawEmitter) {
  var watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;

  var parentPath = sysPath.dirname(watchPath);
  var cont = FSEventsWatchers.get(watchPath);

  // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  var resolvedPath = sysPath.resolve(path);
  var hasSymlink = resolvedPath !== realPath;

  var filteredListener = function filteredListener(fullPath, flags, info) {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);
  };

  // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match
  var watchedParent = false;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = FSEventsWatchers.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var watchedPath = _step.value;

      if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
        watchPath = watchedPath;
        cont = FSEventsWatchers.get(watchPath);
        watchedParent = true;
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter: rawEmitter,
      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {
        if (!cont.listeners.size) return;
        var info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(function (list) {
          list(fullPath, flags, info);
        });

        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }

  // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left
  return function () {
    var lst = cont.listeners;

    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher) return cont.watcher.stop().then(function () {
        cont.rawEmitter = cont.watcher = undefined;
        Object.freeze(cont);
      });
    }
  };
}

// Decide whether or not we should start a new higher-level
// parent watcher
var couldConsolidate = function couldConsolidate(path) {
  var count = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = FSEventsWatchers.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var watchPath = _step2.value;

      if (watchPath.indexOf(path) === 0) {
        count++;
        if (count >= consolidateThreshhold) {
          return true;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return false;
};

// returns boolean indicating whether fsevents can be used
var canUse = function canUse() {
  return fsevents && FSEventsWatchers.size < 128;
};

// determines subdirectory traversal levels from root to path
var calcDepth = function calcDepth(path, root) {
  var i = 0;
  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) {
    i++;
  }return i;
};

// returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat
var sameTypes = function sameTypes(info, stats) {
  return info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
};

/**
 * @mixin
 */

var FsEventsHandler = function () {

  /**
   * @param {import('../index').FSWatcher} fsw
   */
  function FsEventsHandler(fsw) {
    _classCallCheck(this, FsEventsHandler);

    this.fsw = fsw;
  }

  _createClass(FsEventsHandler, [{
    key: 'checkIgnored',
    value: function checkIgnored(path, stats) {
      var ipaths = this.fsw._ignoredPaths;
      if (this.fsw._isIgnored(path, stats)) {
        ipaths.add(path);
        if (stats && stats.isDirectory()) {
          ipaths.add(path + ROOT_GLOBSTAR);
        }
        return true;
      }

      ipaths.delete(path);
      ipaths.delete(path + ROOT_GLOBSTAR);
    }
  }, {
    key: 'addOrChange',
    value: function addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      var event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
      this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }, {
    key: 'checkExists',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        var stats;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return stat(path);

              case 3:
                stats = _context.sent;

                if (!this.fsw.closed) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt('return');

              case 6:
                if (sameTypes(info, stats)) {
                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }
                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context['catch'](0);

                if (_context.t0.code === 'EACCES') {
                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }

              case 12:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 9]]);
      }));

      function checkExists(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {
        return _ref.apply(this, arguments);
      }

      return checkExists;
    }()
  }, {
    key: 'handleEvent',
    value: function handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      if (this.fsw.closed || this.checkIgnored(path)) return;

      if (event === EV_UNLINK) {
        var isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
        // suppress unlink events on never before seen files
        if (isDirectory || watchedDir.has(item)) {
          this.fsw._remove(parent, item, isDirectory);
        }
      } else {
        if (event === EV_ADD) {
          // track new directories
          if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

          if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
            // push symlinks back to the top of the stack to get handled
            var curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;
            return this._addToFsEvents(path, false, true, curDepth);
          }

          // track new paths
          // (other than symlinks being followed, which will be tracked soon)
          this.fsw._getWatchedDir(parent).add(item);
        }
        /**
         * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
         */
        var eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
        this.fsw._emit(eventName, path);
        if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);
      }
    }

    /**
     * Handle symlinks encountered during directory scan
     * @param {String} watchPath  - file/dir path to be watched with fsevents
     * @param {String} realPath   - real path (in case of symlinks)
     * @param {Function} transform  - path transformer
     * @param {Function} globFilter - path filter in case a glob pattern was provided
     * @returns {Function} closer for the watcher instance
    */

  }, {
    key: '_watchWithFsEvents',
    value: function _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
      var _this = this;

      if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
      var opts = this.fsw.options;
      var watchCallback = function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fullPath, flags, info) {
          var path, parent, item, watchedDir, stats;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!_this.fsw.closed) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt('return');

                case 2:
                  if (!(opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth)) {
                    _context2.next = 4;
                    break;
                  }

                  return _context2.abrupt('return');

                case 4:
                  path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));

                  if (!(globFilter && !globFilter(path))) {
                    _context2.next = 7;
                    break;
                  }

                  return _context2.abrupt('return');

                case 7:
                  // ensure directories are tracked
                  parent = sysPath.dirname(path);
                  item = sysPath.basename(path);
                  watchedDir = _this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent);

                  // correct for wrong events emitted

                  if (!(wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN)) {
                    _context2.next = 31;
                    break;
                  }

                  if (!(_typeof(opts.ignored) === FUNCTION_TYPE)) {
                    _context2.next = 28;
                    break;
                  }

                  stats = void 0;
                  _context2.prev = 13;
                  _context2.next = 16;
                  return stat(path);

                case 16:
                  stats = _context2.sent;
                  _context2.next = 21;
                  break;

                case 19:
                  _context2.prev = 19;
                  _context2.t0 = _context2['catch'](13);

                case 21:
                  if (!_this.fsw.closed) {
                    _context2.next = 23;
                    break;
                  }

                  return _context2.abrupt('return');

                case 23:
                  if (!_this.checkIgnored(path, stats)) {
                    _context2.next = 25;
                    break;
                  }

                  return _context2.abrupt('return');

                case 25:
                  if (sameTypes(info, stats)) {
                    _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                  } else {
                    _this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                  }
                  _context2.next = 29;
                  break;

                case 28:
                  _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);

                case 29:
                  _context2.next = 36;
                  break;

                case 31:
                  _context2.t1 = info.event;
                  _context2.next = _context2.t1 === FSEVENT_CREATED ? 34 : _context2.t1 === FSEVENT_MODIFIED ? 34 : _context2.t1 === FSEVENT_DELETED ? 35 : _context2.t1 === FSEVENT_MOVED ? 35 : 36;
                  break;

                case 34:
                  return _context2.abrupt('return', _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts));

                case 35:
                  return _context2.abrupt('return', _this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts));

                case 36:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, _this, [[13, 19]]);
        }));

        return function watchCallback(_x9, _x10, _x11) {
          return _ref2.apply(this, arguments);
        };
      }();

      var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);

      this.fsw._emitReady();
      return closer;
    }

    /**
     * Handle symlinks encountered during directory scan
     * @param {String} linkPath path to symlink
     * @param {String} fullPath absolute path to the symlink
     * @param {Function} transform pre-existing path transformer
     * @param {Number} curDepth level of subdirectories traversed to where symlink is
     * @returns {Promise<void>}
     */

  }, {
    key: '_handleFsEventsSymlink',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(linkPath, fullPath, transform, curDepth) {
        var linkTarget;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt('return');

              case 2:

                this.fsw._symlinkPaths.set(fullPath, true);
                this.fsw._incrReadyCount();

                _context3.prev = 4;
                _context3.next = 7;
                return realpath(linkPath);

              case 7:
                linkTarget = _context3.sent;

                if (!this.fsw.closed) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt('return');

              case 10:
                if (!this.fsw._isIgnored(linkTarget)) {
                  _context3.next = 12;
                  break;
                }

                return _context3.abrupt('return', this.fsw._emitReady());

              case 12:

                this.fsw._incrReadyCount();

                // add the linkTarget for watching with a wrapper for transform
                // that causes emitted paths to incorporate the link's path
                this._addToFsEvents(linkTarget || linkPath, function (path) {
                  var aliasedPath = linkPath;
                  if (linkTarget && linkTarget !== DOT_SLASH) {
                    aliasedPath = path.replace(linkTarget, linkPath);
                  } else if (path !== DOT_SLASH) {
                    aliasedPath = sysPath.join(linkPath, path);
                  }
                  return transform(aliasedPath);
                }, false, curDepth);
                _context3.next = 20;
                break;

              case 16:
                _context3.prev = 16;
                _context3.t0 = _context3['catch'](4);

                if (!this.fsw._handleError(_context3.t0)) {
                  _context3.next = 20;
                  break;
                }

                return _context3.abrupt('return', this.fsw._emitReady());

              case 20:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this, [[4, 16]]);
      }));

      function _handleFsEventsSymlink(_x12, _x13, _x14, _x15) {
        return _ref3.apply(this, arguments);
      }

      return _handleFsEventsSymlink;
    }()

    /**
     *
     * @param {Path} newPath
     * @param {fs.Stats} stats
     */

  }, {
    key: 'emitAdd',
    value: function emitAdd(newPath, stats, processPath, opts, forceAdd) {
      var pp = processPath(newPath);
      var isDir = stats.isDirectory();
      var dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
      var base = sysPath.basename(pp);

      // ensure empty dirs get tracked
      if (isDir) this.fsw._getWatchedDir(pp);
      if (dirObj.has(base)) return;
      dirObj.add(base);

      if (!opts.ignoreInitial || forceAdd === true) {
        this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
      }
    }
  }, {
    key: 'initWatch',
    value: function initWatch(realPath, path, wh, processPath) {
      if (this.fsw.closed) return;
      var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);
      this.fsw._addPathCloser(path, closer);
    }

    /**
     * Handle added path with fsevents
     * @param {String} path file/dir path or glob pattern
     * @param {Function|Boolean=} transform converts working path to what the user expects
     * @param {Boolean=} forceAdd ensure add is emitted
     * @param {Number=} priorDepth Level of subdirectories already traversed.
     * @returns {Promise<void>}
     */

  }, {
    key: '_addToFsEvents',
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path, transform, forceAdd, priorDepth) {
        var _this2 = this;

        var opts, processPath, wh, stats, realPath;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.fsw.closed) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt('return');

              case 2:
                opts = this.fsw.options;
                processPath = (typeof transform === 'undefined' ? 'undefined' : _typeof(transform)) === FUNCTION_TYPE ? transform : IDENTITY_FN;
                wh = this.fsw._getWatchHelpers(path);

                // evaluate what is at the path we're being asked to watch

                _context4.prev = 5;
                _context4.next = 8;
                return statMethods[wh.statMethod](wh.watchPath);

              case 8:
                stats = _context4.sent;

                if (!this.fsw.closed) {
                  _context4.next = 11;
                  break;
                }

                return _context4.abrupt('return');

              case 11:
                if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                  _context4.next = 13;
                  break;
                }

                throw null;

              case 13:
                if (!stats.isDirectory()) {
                  _context4.next = 20;
                  break;
                }

                // emit addDir unless this is a glob parent
                if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);

                // don't recurse further if it would exceed depth setting

                if (!(priorDepth && priorDepth > opts.depth)) {
                  _context4.next = 17;
                  break;
                }

                return _context4.abrupt('return');

              case 17:

                // scan the contents of the dir
                this.fsw._readdirp(wh.watchPath, Object.assign({
                  fileFilter: function fileFilter(entry) {
                    return wh.filterPath(entry);
                  },
                  directoryFilter: function directoryFilter(entry) {
                    return wh.filterDir(entry);
                  }
                }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, function (entry) {
                  // need to check filterPath on dirs b/c filterDir is less restrictive
                  if (_this2.fsw.closed) {
                    return;
                  }
                  if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;

                  var joinedPath = sysPath.join(wh.watchPath, entry.path);
                  var fullPath = entry.fullPath;


                  if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                    // preserve the current depth here since it can't be derived from
                    // real paths past the symlink
                    var curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

                    _this2._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                  } else {
                    _this2.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                  }
                }).on(EV_ERROR, EMPTY_FN).on(STR_END, function () {
                  _this2.fsw._emitReady();
                });
                _context4.next = 22;
                break;

              case 20:
                this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
                this.fsw._emitReady();

              case 22:
                _context4.next = 27;
                break;

              case 24:
                _context4.prev = 24;
                _context4.t0 = _context4['catch'](5);

                if (!_context4.t0 || this.fsw._handleError(_context4.t0)) {
                  // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
                  this.fsw._emitReady();
                  this.fsw._emitReady();
                }

              case 27:
                if (!(opts.persistent && forceAdd !== true)) {
                  _context4.next = 42;
                  break;
                }

                if (!((typeof transform === 'undefined' ? 'undefined' : _typeof(transform)) === FUNCTION_TYPE)) {
                  _context4.next = 32;
                  break;
                }

                // realpath has already been resolved
                this.initWatch(undefined, path, wh, processPath);
                _context4.next = 42;
                break;

              case 32:
                realPath = void 0;
                _context4.prev = 33;
                _context4.next = 36;
                return realpath(wh.watchPath);

              case 36:
                realPath = _context4.sent;
                _context4.next = 41;
                break;

              case 39:
                _context4.prev = 39;
                _context4.t1 = _context4['catch'](33);

              case 41:
                this.initWatch(realPath, path, wh, processPath);

              case 42:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this, [[5, 24], [33, 39]]);
      }));

      function _addToFsEvents(_x16, _x17, _x18, _x19) {
        return _ref4.apply(this, arguments);
      }

      return _addToFsEvents;
    }()
  }]);

  return FsEventsHandler;
}();

module.exports = FsEventsHandler;
module.exports.canUse = canUse;