'use strict';

import _regeneratorRuntime from 'babel-runtime/regenerator';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _this = this;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var fs = require('fs');
var sysPath = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var isBinaryPath = require('is-binary-path');

var _require2 = require('./constants'),
    isWindows = _require2.isWindows,
    isLinux = _require2.isLinux,
    EMPTY_FN = _require2.EMPTY_FN,
    EMPTY_STR = _require2.EMPTY_STR,
    KEY_LISTENERS = _require2.KEY_LISTENERS,
    KEY_ERR = _require2.KEY_ERR,
    KEY_RAW = _require2.KEY_RAW,
    HANDLER_KEYS = _require2.HANDLER_KEYS,
    EV_CHANGE = _require2.EV_CHANGE,
    EV_ADD = _require2.EV_ADD,
    EV_ADD_DIR = _require2.EV_ADD_DIR,
    EV_ERROR = _require2.EV_ERROR,
    STR_DATA = _require2.STR_DATA,
    STR_END = _require2.STR_END,
    BRACE_START = _require2.BRACE_START,
    STAR = _require2.STAR;

var THROTTLE_MODE_WATCH = 'watch';

var open = promisify(fs.open);
var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
var close = promisify(fs.close);
var fsrealpath = promisify(fs.realpath);

var statMethods = { lstat: lstat, stat: stat };

// TODO: emit errors properly. Example: EMFILE on Macos.
var foreach = function foreach(val, fn) {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

var addAndConvert = function addAndConvert(main, prop, item) {
  var container = main[prop];
  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }
  container.add(item);
};

var clearItem = function clearItem(cont) {
  return function (key) {
    var set = cont[key];
    if (set instanceof Set) {
      set.clear();
    } else {
      delete cont[key];
    }
  };
};

var delFromSet = function delFromSet(main, prop, item) {
  var container = main[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main[prop];
  }
};

var isEmptySet = function isEmptySet(val) {
  return val instanceof Set ? val.size === 0 : !val;
};

/**
 * @typedef {String} Path
 */

// fs_watch helpers

// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */
var FsWatchInstances = new Map();

/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  var handleEvent = function handleEvent(rawEvent, evPath) {
    listener(path);
    emitRaw(rawEvent, evPath, { watchedPath: path });

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */
var fsWatchBroadcast = function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
  var cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], function (listener) {
    listener(val1, val2, val3);
  });
};

/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */
var setFsWatchListener = function setFsWatchListener(path, fullPath, options, handlers) {
  var listener = handlers.listener,
      errHandler = handlers.errHandler,
      rawEmitter = handlers.rawEmitter;

  var cont = FsWatchInstances.get(fullPath);

  /** @type {fs.FSWatcher=} */
  var watcher = void 0;
  if (!options.persistent) {
    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here
    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
    if (!watcher) return;
    watcher.on(EV_ERROR, function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(error) {
        var broadcastErr, fd;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);

                cont.watcherUnusable = true; // documented since Node 10.4.1
                // Workaround for https://github.com/joyent/node/issues/4337

                if (!(isWindows && error.code === 'EPERM')) {
                  _context.next = 16;
                  break;
                }

                _context.prev = 3;
                _context.next = 6;
                return open(path, 'r');

              case 6:
                fd = _context.sent;
                _context.next = 9;
                return close(fd);

              case 9:
                broadcastErr(error);
                _context.next = 14;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context['catch'](3);

              case 14:
                _context.next = 17;
                break;

              case 16:
                broadcastErr(error);

              case 17:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this, [[3, 12]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher: watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left
  return function () {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close();
      // }
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

// fs_watchFile helpers

// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
var FsWatchFileInstances = new Map();

/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */
var setFsWatchFileListener = function setFsWatchFileListener(path, fullPath, options, handlers) {
  var listener = handlers.listener,
      rawEmitter = handlers.rawEmitter;

  var cont = FsWatchFileInstances.get(fullPath);

  /* eslint-disable no-unused-vars, prefer-destructuring */
  var listeners = new Set();
  var rawEmitters = new Set();

  var copts = cont && cont.options;
  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = cont.listeners;
    rawEmitters = cont.rawEmitters;
    fs.unwatchFile(fullPath);
    cont = undefined;
  }

  /* eslint-enable no-unused-vars, prefer-destructuring */

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options: options,
      watcher: fs.watchFile(fullPath, options, function (curr, prev) {
        foreach(cont.rawEmitters, function (rawEmitter) {
          rawEmitter(EV_CHANGE, fullPath, { curr: curr, prev: prev });
        });
        var currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, function (listener) {
            return listener(path, curr);
          });
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.
  return function () {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      fs.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

/**
 * @mixin
 */

var NodeFsHandler = function () {

  /**
   * @param {import("../index").FSWatcher} fsW
   */
  function NodeFsHandler(fsW) {
    _classCallCheck(this, NodeFsHandler);

    this.fsw = fsW;
    this._boundHandleError = function (error) {
      return fsW._handleError(error);
    };
  }

  /**
   * Watch file for changes with fs_watchFile or fs_watch.
   * @param {String} path to file or dir
   * @param {Function} listener on fs change
   * @returns {Function} closer for the watcher instance
   */


  _createClass(NodeFsHandler, [{
    key: '_watchWithNodeFs',
    value: function _watchWithNodeFs(path, listener) {
      var opts = this.fsw.options;
      var directory = sysPath.dirname(path);
      var basename = sysPath.basename(path);
      var parent = this.fsw._getWatchedDir(directory);
      parent.add(basename);
      var absolutePath = sysPath.resolve(path);
      var options = { persistent: opts.persistent };
      if (!listener) listener = EMPTY_FN;

      var closer = void 0;
      if (opts.usePolling) {
        options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
        closer = setFsWatchFileListener(path, absolutePath, options, {
          listener: listener,
          rawEmitter: this.fsw._emitRaw
        });
      } else {
        closer = setFsWatchListener(path, absolutePath, options, {
          listener: listener,
          errHandler: this._boundHandleError,
          rawEmitter: this.fsw._emitRaw
        });
      }
      return closer;
    }

    /**
     * Watch a file and emit add event if warranted.
     * @param {Path} file Path
     * @param {fs.Stats} stats result of fs_stat
     * @param {Boolean} initialAdd was the file added at watch instantiation?
     * @returns {Function} closer for the watcher instance
     */

  }, {
    key: '_handleFile',
    value: function _handleFile(file, stats, initialAdd) {
      var _this2 = this;

      if (this.fsw.closed) {
        return;
      }
      var dirname = sysPath.dirname(file);
      var basename = sysPath.basename(file);
      var parent = this.fsw._getWatchedDir(dirname);
      // stats is always present
      var prevStats = stats;

      // if the file is already being watched, do nothing
      if (parent.has(basename)) return;

      var listener = function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, newStats) {
          var _newStats, at, mt, _at, _mt;

          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (_this2.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt('return');

                case 2:
                  if (!(!newStats || newStats.mtimeMs === 0)) {
                    _context2.next = 20;
                    break;
                  }

                  _context2.prev = 3;
                  _context2.next = 6;
                  return stat(file);

                case 6:
                  _newStats = _context2.sent;

                  if (!_this2.fsw.closed) {
                    _context2.next = 9;
                    break;
                  }

                  return _context2.abrupt('return');

                case 9:
                  // Check that change event was not fired because of changed only accessTime.
                  at = _newStats.atimeMs;
                  mt = _newStats.mtimeMs;

                  if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                    _this2.fsw._emit(EV_CHANGE, file, _newStats);
                  }
                  if (isLinux && prevStats.ino !== _newStats.ino) {
                    _this2.fsw._closeFile(path);
                    prevStats = _newStats;
                    _this2.fsw._addPathCloser(path, _this2._watchWithNodeFs(file, listener));
                  } else {
                    prevStats = _newStats;
                  }
                  _context2.next = 18;
                  break;

                case 15:
                  _context2.prev = 15;
                  _context2.t0 = _context2['catch'](3);

                  // Fix issues where mtime is null but file is still present
                  _this2.fsw._remove(dirname, basename);

                case 18:
                  _context2.next = 21;
                  break;

                case 20:
                  if (parent.has(basename)) {
                    // Check that change event was not fired because of changed only accessTime.
                    _at = newStats.atimeMs;
                    _mt = newStats.mtimeMs;

                    if (!_at || _at <= _mt || _mt !== prevStats.mtimeMs) {
                      _this2.fsw._emit(EV_CHANGE, file, newStats);
                    }
                    prevStats = newStats;
                  }

                case 21:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, _this2, [[3, 15]]);
        }));

        return function listener(_x2, _x3) {
          return _ref2.apply(this, arguments);
        };
      }();
      // kick off the watcher
      var closer = this._watchWithNodeFs(file, listener);

      // emit an add event if we're supposed to
      if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
        if (!this.fsw._throttle(EV_ADD, file, 0)) return;
        this.fsw._emit(EV_ADD, file, stats);
      }

      return closer;
    }

    /**
     * Handle symlinks encountered while reading a dir.
     * @param {Object} entry returned by readdirp
     * @param {String} directory path of dir being read
     * @param {String} path of this item
     * @param {String} item basename of this item
     * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
     */

  }, {
    key: '_handleSymlink',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(entry, directory, path, item) {
        var full, dir, linkPath;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.fsw.closed) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt('return');

              case 2:
                full = entry.fullPath;
                dir = this.fsw._getWatchedDir(directory);

                if (this.fsw.options.followSymlinks) {
                  _context3.next = 22;
                  break;
                }

                // watch symlink directly (don't follow) and detect changes
                this.fsw._incrReadyCount();

                linkPath = void 0;
                _context3.prev = 7;
                _context3.next = 10;
                return fsrealpath(path);

              case 10:
                linkPath = _context3.sent;
                _context3.next = 17;
                break;

              case 13:
                _context3.prev = 13;
                _context3.t0 = _context3['catch'](7);

                this.fsw._emitReady();
                return _context3.abrupt('return', true);

              case 17:
                if (!this.fsw.closed) {
                  _context3.next = 19;
                  break;
                }

                return _context3.abrupt('return');

              case 19:
                if (dir.has(item)) {
                  if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                    this.fsw._symlinkPaths.set(full, linkPath);
                    this.fsw._emit(EV_CHANGE, path, entry.stats);
                  }
                } else {
                  dir.add(item);
                  this.fsw._symlinkPaths.set(full, linkPath);
                  this.fsw._emit(EV_ADD, path, entry.stats);
                }
                this.fsw._emitReady();
                return _context3.abrupt('return', true);

              case 22:
                if (!this.fsw._symlinkPaths.has(full)) {
                  _context3.next = 24;
                  break;
                }

                return _context3.abrupt('return', true);

              case 24:

                this.fsw._symlinkPaths.set(full, true);

              case 25:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this, [[7, 13]]);
      }));

      function _handleSymlink(_x4, _x5, _x6, _x7) {
        return _ref3.apply(this, arguments);
      }

      return _handleSymlink;
    }()
  }, {
    key: '_handleRead',
    value: function _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
      var _this3 = this;

      // Normalize the directory name on Windows
      directory = sysPath.join(directory, EMPTY_STR);

      if (!wh.hasGlob) {
        throttler = this.fsw._throttle('readdir', directory, 1000);
        if (!throttler) return;
      }

      var previous = this.fsw._getWatchedDir(wh.path);
      var current = new Set();

      var stream = this.fsw._readdirp(directory, {
        fileFilter: function fileFilter(entry) {
          return wh.filterPath(entry);
        },
        directoryFilter: function directoryFilter(entry) {
          return wh.filterDir(entry);
        },
        depth: 0
      }).on(STR_DATA, function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(entry) {
          var item, path;
          return _regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (!_this3.fsw.closed) {
                    _context4.next = 3;
                    break;
                  }

                  stream = undefined;
                  return _context4.abrupt('return');

                case 3:
                  item = entry.path;
                  path = sysPath.join(directory, item);

                  current.add(item);

                  _context4.t0 = entry.stats.isSymbolicLink();

                  if (!_context4.t0) {
                    _context4.next = 11;
                    break;
                  }

                  _context4.next = 10;
                  return _this3._handleSymlink(entry, directory, path, item);

                case 10:
                  _context4.t0 = _context4.sent;

                case 11:
                  if (!_context4.t0) {
                    _context4.next = 13;
                    break;
                  }

                  return _context4.abrupt('return');

                case 13:
                  if (!_this3.fsw.closed) {
                    _context4.next = 16;
                    break;
                  }

                  stream = undefined;
                  return _context4.abrupt('return');

                case 16:
                  // Files that present in current directory snapshot
                  // but absent in previous are added to watch list and
                  // emit `add` event.
                  if (item === target || !target && !previous.has(item)) {
                    _this3.fsw._incrReadyCount();

                    // ensure relativeness of path is preserved in case of watcher reuse
                    path = sysPath.join(dir, sysPath.relative(dir, path));

                    _this3._addToNodeFs(path, initialAdd, wh, depth + 1);
                  }

                case 17:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, _this3);
        }));

        return function (_x8) {
          return _ref4.apply(this, arguments);
        };
      }()).on(EV_ERROR, this._boundHandleError);

      return new Promise(function (resolve) {
        return stream.once(STR_END, function () {
          if (_this3.fsw.closed) {
            stream = undefined;
            return;
          }
          var wasThrottled = throttler ? throttler.clear() : false;

          resolve();

          // Files that absent in current directory snapshot
          // but present in previous emit `remove` event
          // and are removed from @watched[directory].
          previous.getChildren().filter(function (item) {
            return item !== directory && !current.has(item) && (
            // in case of intersecting globs;
            // a path may have been filtered out of this readdir, but
            // shouldn't be removed because it matches a different glob
            !wh.hasGlob || wh.filterPath({
              fullPath: sysPath.resolve(directory, item)
            }));
          }).forEach(function (item) {
            _this3.fsw._remove(directory, item);
          });

          stream = undefined;

          // one more time for any missed in case changes came in extremely quickly
          if (wasThrottled) _this3._handleRead(directory, false, wh, target, dir, depth, throttler);
        });
      });
    }

    /**
     * Read directory to add / remove files from `@watched` list and re-read it on change.
     * @param {String} dir fs path
     * @param {fs.Stats} stats
     * @param {Boolean} initialAdd
     * @param {Number} depth relative to user-supplied path
     * @param {String} target child path targeted for watch
     * @param {Object} wh Common watch helpers for this path
     * @param {String} realpath
     * @returns {Promise<Function>} closer for the watcher instance.
     */

  }, {
    key: '_handleDir',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(dir, stats, initialAdd, depth, target, wh, realpath) {
        var _this4 = this;

        var parentDir, tracked, throttler, closer, oDepth;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
                tracked = parentDir.has(sysPath.basename(dir));

                if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
                  if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);
                }

                // ensure dir is tracked (harmless if redundant)
                parentDir.add(sysPath.basename(dir));
                this.fsw._getWatchedDir(dir);
                throttler = void 0;
                closer = void 0;
                oDepth = this.fsw.options.depth;

                if (!((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath))) {
                  _context5.next = 15;
                  break;
                }

                if (target) {
                  _context5.next = 14;
                  break;
                }

                _context5.next = 12;
                return this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);

              case 12:
                if (!this.fsw.closed) {
                  _context5.next = 14;
                  break;
                }

                return _context5.abrupt('return');

              case 14:

                closer = this._watchWithNodeFs(dir, function (dirPath, stats) {
                  // if current directory is removed, do nothing
                  if (stats && stats.mtimeMs === 0) return;

                  _this4._handleRead(dirPath, false, wh, target, dir, depth, throttler);
                });

              case 15:
                return _context5.abrupt('return', closer);

              case 16:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _handleDir(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {
        return _ref5.apply(this, arguments);
      }

      return _handleDir;
    }()

    /**
     * Handle added file, directory, or glob pattern.
     * Delegates call to _handleFile / _handleDir after checks.
     * @param {String} path to file or ir
     * @param {Boolean} initialAdd was the file added at watch instantiation?
     * @param {Object} priorWh depth relative to user-supplied path
     * @param {Number} depth Child path actually targeted for watch
     * @param {String=} target Child path actually targeted for watch
     * @returns {Promise}
     */

  }, {
    key: '_addToNodeFs',
    value: function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(path, initialAdd, priorWh, depth, target) {
        var ready, wh, stats, follow, closer, absPath, targetPath, _targetPath, parent;

        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                ready = this.fsw._emitReady;

                if (!(this.fsw._isIgnored(path) || this.fsw.closed)) {
                  _context6.next = 4;
                  break;
                }

                ready();
                return _context6.abrupt('return', false);

              case 4:
                wh = this.fsw._getWatchHelpers(path, depth);

                if (!wh.hasGlob && priorWh) {
                  wh.hasGlob = priorWh.hasGlob;
                  wh.globFilter = priorWh.globFilter;
                  wh.filterPath = function (entry) {
                    return priorWh.filterPath(entry);
                  };
                  wh.filterDir = function (entry) {
                    return priorWh.filterDir(entry);
                  };
                }

                // evaluate what is at the path we're being asked to watch
                _context6.prev = 6;
                _context6.next = 9;
                return statMethods[wh.statMethod](wh.watchPath);

              case 9:
                stats = _context6.sent;

                if (!this.fsw.closed) {
                  _context6.next = 12;
                  break;
                }

                return _context6.abrupt('return');

              case 12:
                if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                  _context6.next = 15;
                  break;
                }

                ready();
                return _context6.abrupt('return', false);

              case 15:
                follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);
                closer = void 0;

                if (!stats.isDirectory()) {
                  _context6.next = 37;
                  break;
                }

                absPath = sysPath.resolve(path);

                if (!follow) {
                  _context6.next = 25;
                  break;
                }

                _context6.next = 22;
                return fsrealpath(path);

              case 22:
                _context6.t0 = _context6.sent;
                _context6.next = 26;
                break;

              case 25:
                _context6.t0 = path;

              case 26:
                targetPath = _context6.t0;

                if (!this.fsw.closed) {
                  _context6.next = 29;
                  break;
                }

                return _context6.abrupt('return');

              case 29:
                _context6.next = 31;
                return this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);

              case 31:
                closer = _context6.sent;

                if (!this.fsw.closed) {
                  _context6.next = 34;
                  break;
                }

                return _context6.abrupt('return');

              case 34:
                // preserve this symlink's target path
                if (absPath !== targetPath && targetPath !== undefined) {
                  this.fsw._symlinkPaths.set(absPath, targetPath);
                }
                _context6.next = 60;
                break;

              case 37:
                if (!stats.isSymbolicLink()) {
                  _context6.next = 59;
                  break;
                }

                if (!follow) {
                  _context6.next = 44;
                  break;
                }

                _context6.next = 41;
                return fsrealpath(path);

              case 41:
                _context6.t1 = _context6.sent;
                _context6.next = 45;
                break;

              case 44:
                _context6.t1 = path;

              case 45:
                _targetPath = _context6.t1;

                if (!this.fsw.closed) {
                  _context6.next = 48;
                  break;
                }

                return _context6.abrupt('return');

              case 48:
                parent = sysPath.dirname(wh.watchPath);

                this.fsw._getWatchedDir(parent).add(wh.watchPath);
                this.fsw._emit(EV_ADD, wh.watchPath, stats);
                _context6.next = 53;
                return this._handleDir(parent, stats, initialAdd, depth, path, wh, _targetPath);

              case 53:
                closer = _context6.sent;

                if (!this.fsw.closed) {
                  _context6.next = 56;
                  break;
                }

                return _context6.abrupt('return');

              case 56:

                // preserve this symlink's target path
                if (_targetPath !== undefined) {
                  this.fsw._symlinkPaths.set(sysPath.resolve(path), _targetPath);
                }
                _context6.next = 60;
                break;

              case 59:
                closer = this._handleFile(wh.watchPath, stats, initialAdd);

              case 60:
                ready();

                this.fsw._addPathCloser(path, closer);
                return _context6.abrupt('return', false);

              case 65:
                _context6.prev = 65;
                _context6.t2 = _context6['catch'](6);

                if (!this.fsw._handleError(_context6.t2)) {
                  _context6.next = 70;
                  break;
                }

                ready();
                return _context6.abrupt('return', path);

              case 70:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this, [[6, 65]]);
      }));

      function _addToNodeFs(_x16, _x17, _x18, _x19, _x20) {
        return _ref6.apply(this, arguments);
      }

      return _addToNodeFs;
    }()
  }]);

  return NodeFsHandler;
}();

module.exports = NodeFsHandler;