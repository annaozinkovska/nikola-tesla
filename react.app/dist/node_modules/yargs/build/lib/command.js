var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

import { assertNotStrictEqual } from './typings/common-types.js';
import { isPromise } from './utils/is-promise.js';
import { applyMiddleware, commandMiddlewareFactory } from './middleware.js';
import { parseCommand } from './parse-command.js';
import { isYargsInstance } from './yargs-factory.js';
import whichModule from './utils/which-module.js';
var DEFAULT_MARKER = /(^\*)|(^\$0)/;
export function command(yargs, usage, validation) {
    var globalMiddleware = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var shim = arguments[4];

    var self = {};
    var handlers = {};
    var aliasMap = {};
    var defaultCommand = void 0;
    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        var aliases = [];
        var middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || function () {};
        if (Array.isArray(cmd)) {
            if (isCommandAndAliases(cmd)) {
                var _cmd = cmd;

                var _cmd2 = _toArray(_cmd);

                cmd = _cmd2[0];
                aliases = _cmd2.slice(1);
            } else {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = cmd[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _command = _step.value;

                        self.addHandler(_command);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        } else if (isCommandHandlerDefinition(cmd)) {
            var _command2 = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);
            if (cmd.aliases) _command2 = [].concat(_command2).concat(cmd.aliases);
            self.addHandler(_command2, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
            return;
        } else if (isCommandBuilderDefinition(builder)) {
            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
            return;
        }
        if (typeof cmd === 'string') {
            var parsedCommand = parseCommand(cmd);
            aliases = aliases.map(function (alias) {
                return parseCommand(alias).cmd;
            });
            var isDefault = false;
            var parsedAliases = [parsedCommand.cmd].concat(aliases).filter(function (c) {
                if (DEFAULT_MARKER.test(c)) {
                    isDefault = true;
                    return false;
                }
                return true;
            });
            if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0');
            if (isDefault) {
                parsedCommand.cmd = parsedAliases[0];
                aliases = parsedAliases.slice(1);
                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
            }
            aliases.forEach(function (alias) {
                aliasMap[alias] = parsedCommand.cmd;
            });
            if (description !== false) {
                usage.command(cmd, description, isDefault, aliases, deprecated);
            }
            handlers[parsedCommand.cmd] = {
                original: cmd,
                description: description,
                handler: handler,
                builder: builder || {},
                middlewares: middlewares,
                deprecated: deprecated,
                demanded: parsedCommand.demanded,
                optional: parsedCommand.optional
            };
            if (isDefault) defaultCommand = handlers[parsedCommand.cmd];
        }
    };
    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {
        opts = opts || {};
        if (typeof opts.recurse !== 'boolean') opts.recurse = false;
        if (!Array.isArray(opts.extensions)) opts.extensions = ['js'];
        var parentVisit = typeof opts.visit === 'function' ? opts.visit : function (o) {
            return o;
        };
        opts.visit = function visit(obj, joined, filename) {
            var visited = parentVisit(obj, joined, filename);
            if (visited) {
                if (~context.files.indexOf(joined)) return visited;
                context.files.push(joined);
                self.addHandler(visited);
            }
            return visited;
        };
        shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);
    };
    function moduleName(obj) {
        var mod = whichModule(obj);
        if (!mod) throw new Error('No command name given for module: ' + shim.inspect(obj));
        return commandFromFilename(mod.filename);
    }
    function commandFromFilename(filename) {
        return shim.path.basename(filename, shim.path.extname(filename));
    }
    function extractDesc(_ref) {
        var describe = _ref.describe,
            description = _ref.description,
            desc = _ref.desc;
        var _arr = [describe, description, desc];

        for (var _i = 0; _i < _arr.length; _i++) {
            var test = _arr[_i];
            if (typeof test === 'string' || test === false) return test;
            assertNotStrictEqual(test, true, shim);
        }
        return false;
    }
    self.getCommands = function () {
        return Object.keys(handlers).concat(Object.keys(aliasMap));
    };
    self.getCommandHandlers = function () {
        return handlers;
    };
    self.hasDefaultCommand = function () {
        return !!defaultCommand;
    };
    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {
        var aliases = parsed.aliases;
        var commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;
        var currentContext = yargs.getContext();
        var numFiles = currentContext.files.length;
        var parentCommands = currentContext.commands.slice();
        var innerArgv = parsed.argv;
        var positionalMap = {};
        if (command) {
            currentContext.commands.push(command);
            currentContext.fullCommands.push(commandHandler.original);
        }
        var builder = commandHandler.builder;
        if (isCommandBuilderCallback(builder)) {
            var builderOutput = builder(yargs.reset(parsed.aliases));
            var innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs;
            if (shouldUpdateUsage(innerYargs)) {
                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
            }
            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
            aliases = innerYargs.parsed.aliases;
        } else if (isCommandBuilderOptionDefinitions(builder)) {
            var _innerYargs = yargs.reset(parsed.aliases);
            if (shouldUpdateUsage(_innerYargs)) {
                _innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
            }
            Object.keys(commandHandler.builder).forEach(function (key) {
                _innerYargs.option(key, builder[key]);
            });
            innerArgv = _innerYargs._parseArgs(null, null, true, commandIndex);
            aliases = _innerYargs.parsed.aliases;
        }
        if (!yargs._hasOutput()) {
            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);
        }
        var middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);
        applyMiddleware(innerArgv, yargs, middlewares, true);
        if (!yargs._hasOutput()) {
            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);
        }
        if (commandHandler.handler && !yargs._hasOutput()) {
            yargs._setHasOutput();
            var populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
            yargs._postProcess(innerArgv, populateDoubleDash);
            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
            var handlerResult = void 0;
            if (isPromise(innerArgv)) {
                handlerResult = innerArgv.then(function (argv) {
                    return commandHandler.handler(argv);
                });
            } else {
                handlerResult = commandHandler.handler(innerArgv);
            }
            var handlerFinishCommand = yargs.getHandlerFinishCommand();
            if (isPromise(handlerResult)) {
                yargs.getUsageInstance().cacheHelpMessage();
                handlerResult.then(function (value) {
                    if (handlerFinishCommand) {
                        handlerFinishCommand(value);
                    }
                }).catch(function (error) {
                    try {
                        yargs.getUsageInstance().fail(null, error);
                    } catch (err) {}
                }).then(function () {
                    yargs.getUsageInstance().clearCachedHelpMessage();
                });
            } else {
                if (handlerFinishCommand) {
                    handlerFinishCommand(handlerResult);
                }
            }
        }
        if (command) {
            currentContext.commands.pop();
            currentContext.fullCommands.pop();
        }
        numFiles = currentContext.files.length - numFiles;
        if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);
        return innerArgv;
    };
    function shouldUpdateUsage(yargs) {
        return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;
    }
    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        var c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;
        var pc = parentCommands.filter(function (c) {
            return !DEFAULT_MARKER.test(c);
        });
        pc.push(c);
        return '$0 ' + pc.join(' ');
    }
    self.runDefaultBuilderOn = function (yargs) {
        assertNotStrictEqual(defaultCommand, undefined, shim);
        if (shouldUpdateUsage(yargs)) {
            var commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
            yargs.getUsageInstance().usage(commandString, defaultCommand.description);
        }
        var builder = defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
            builder(yargs);
        } else if (!isCommandBuilderDefinition(builder)) {
            Object.keys(builder).forEach(function (key) {
                yargs.option(key, builder[key]);
            });
        }
    };
    function populatePositionals(commandHandler, argv, context) {
        argv._ = argv._.slice(context.commands.length);
        var demanded = commandHandler.demanded.slice(0);
        var optional = commandHandler.optional.slice(0);
        var positionalMap = {};
        validation.positionalCount(demanded.length, argv._.length);
        while (demanded.length) {
            var demand = demanded.shift();
            populatePositional(demand, argv, positionalMap);
        }
        while (optional.length) {
            var maybe = optional.shift();
            populatePositional(maybe, argv, positionalMap);
        }
        argv._ = context.commands.concat(argv._.map(function (a) {
            return '' + a;
        }));
        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));
        return positionalMap;
    }
    function populatePositional(positional, argv, positionalMap) {
        var cmd = positional.cmd[0];
        if (positional.variadic) {
            positionalMap[cmd] = argv._.splice(0).map(String);
        } else {
            if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];
        }
    }
    function postProcessPositionals(argv, positionalMap, parseOptions) {
        var options = Object.assign({}, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = Object.keys(parseOptions.alias)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var key = _step2.value;

                options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        options.array = options.array.concat(parseOptions.array);
        options.config = {};
        var unparsed = [];
        Object.keys(positionalMap).forEach(function (key) {
            positionalMap[key].map(function (value) {
                if (options.configuration['unknown-options-as-args']) options.key[key] = true;
                unparsed.push('--' + key);
                unparsed.push(value);
            });
        });
        if (!unparsed.length) return;
        var config = Object.assign({}, options.configuration, {
            'populate--': true
        });
        var parsed = shim.Parser.detailed(unparsed, Object.assign({}, options, {
            configuration: config
        }));
        if (parsed.error) {
            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);
        } else {
            var positionalKeys = Object.keys(positionalMap);
            Object.keys(positionalMap).forEach(function (key) {
                positionalKeys.push.apply(positionalKeys, _toConsumableArray(parsed.aliases[key]));
            });
            Object.keys(parsed.argv).forEach(function (key) {
                if (positionalKeys.indexOf(key) !== -1) {
                    if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];
                    argv[key] = parsed.argv[key];
                }
            });
        }
    }
    self.cmdToParseOptions = function (cmdString) {
        var parseOptions = {
            array: [],
            default: {},
            alias: {},
            demand: {}
        };
        var parsed = parseCommand(cmdString);
        parsed.demanded.forEach(function (d) {
            var _d$cmd = _toArray(d.cmd),
                cmd = _d$cmd[0],
                aliases = _d$cmd.slice(1);

            if (d.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
            parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach(function (o) {
            var _o$cmd = _toArray(o.cmd),
                cmd = _o$cmd[0],
                aliases = _o$cmd.slice(1);

            if (o.variadic) {
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
            }
            parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
    };
    self.reset = function () {
        handlers = {};
        aliasMap = {};
        defaultCommand = undefined;
        return self;
    };
    var frozens = [];
    self.freeze = function () {
        frozens.push({
            handlers: handlers,
            aliasMap: aliasMap,
            defaultCommand: defaultCommand
        });
    };
    self.unfreeze = function () {
        var frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        handlers = frozen.handlers;
        aliasMap = frozen.aliasMap;
        defaultCommand = frozen.defaultCommand;
    };
    return self;
}
export function isCommandBuilderDefinition(builder) {
    return (typeof builder === 'undefined' ? 'undefined' : _typeof(builder)) === 'object' && !!builder.builder && typeof builder.handler === 'function';
}
function isCommandAndAliases(cmd) {
    if (cmd.every(function (c) {
        return typeof c === 'string';
    })) {
        return true;
    } else {
        return false;
    }
}
export function isCommandBuilderCallback(builder) {
    return typeof builder === 'function';
}
function isCommandBuilderOptionDefinitions(builder) {
    return (typeof builder === 'undefined' ? 'undefined' : _typeof(builder)) === 'object';
}
export function isCommandHandlerDefinition(cmd) {
    return (typeof cmd === 'undefined' ? 'undefined' : _typeof(cmd)) === 'object' && !Array.isArray(cmd);
}