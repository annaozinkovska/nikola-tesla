var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import { argsert } from './argsert.js';
import { assertNotStrictEqual } from './typings/common-types.js';
import { levenshtein as distance } from './utils/levenshtein.js';
import { objFilter } from './utils/obj-filter.js';
var specialKeys = ['$0', '--', '_'];
export function validation(yargs, usage, y18n, shim) {
    var __ = y18n.__;
    var __n = y18n.__n;
    var self = {};
    self.nonOptionCount = function nonOptionCount(argv) {
        var demandedCommands = yargs.getDemandedCommands();
        var positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
        var _s = positionalCount - yargs.getContext().commands.length;
        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
            if (_s < demandedCommands._.min) {
                if (demandedCommands._.minMsg !== undefined) {
                    usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
                } else {
                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
                }
            } else if (_s > demandedCommands._.max) {
                if (demandedCommands._.maxMsg !== undefined) {
                    usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
                } else {
                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
                }
            }
        }
    };
    self.positionalCount = function positionalCount(required, observed) {
        if (observed < required) {
            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
        }
    };
    self.requiredArguments = function requiredArguments(argv) {
        var demandedOptions = yargs.getDemandedOptions();
        var missing = null;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Object.keys(demandedOptions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var key = _step.value;

                if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {
                    missing = missing || {};
                    missing[key] = demandedOptions[key];
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        if (missing) {
            var customMsgs = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Object.keys(missing)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _key = _step2.value;

                    var msg = missing[_key];
                    if (msg && customMsgs.indexOf(msg) < 0) {
                        customMsgs.push(msg);
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            var customMsg = customMsgs.length ? '\n' + customMsgs.join('\n') : '';
            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
        }
    };
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {
        var checkPositionals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

        var commandKeys = yargs.getCommandInstance().getCommands();
        var unknown = [];
        var currentContext = yargs.getContext();
        Object.keys(argv).forEach(function (key) {
            if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
                unknown.push(key);
            }
        });
        if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
            argv._.slice(currentContext.commands.length).forEach(function (key) {
                if (commandKeys.indexOf('' + key) === -1) {
                    unknown.push('' + key);
                }
            });
        }
        if (unknown.length > 0) {
            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));
        }
    };
    self.unknownCommands = function unknownCommands(argv) {
        var commandKeys = yargs.getCommandInstance().getCommands();
        var unknown = [];
        var currentContext = yargs.getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) {
            argv._.slice(currentContext.commands.length).forEach(function (key) {
                if (commandKeys.indexOf('' + key) === -1) {
                    unknown.push('' + key);
                }
            });
        }
        if (unknown.length > 0) {
            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
            return true;
        } else {
            return false;
        }
    };
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
            return false;
        }
        var newAliases = yargs.parsed.newAliases;

        var _arr = [key].concat(_toConsumableArray(aliases[key]));

        for (var _i = 0; _i < _arr.length; _i++) {
            var a = _arr[_i];
            if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {
                return true;
            }
        }
        return false;
    };
    self.limitedChoices = function limitedChoices(argv) {
        var options = yargs.getOptions();
        var invalid = {};
        if (!Object.keys(options.choices).length) return;
        Object.keys(argv).forEach(function (key) {
            if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
                [].concat(argv[key]).forEach(function (value) {
                    if (options.choices[key].indexOf(value) === -1 && value !== undefined) {
                        invalid[key] = (invalid[key] || []).concat(value);
                    }
                });
            }
        });
        var invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length) return;
        var msg = __('Invalid values:');
        invalidKeys.forEach(function (key) {
            msg += '\n  ' + __('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]));
        });
        usage.fail(msg);
    };
    var checks = [];
    self.check = function check(f, global) {
        checks.push({
            func: f,
            global: global
        });
    };
    self.customChecks = function customChecks(argv, aliases) {
        for (var i = 0, f; (f = checks[i]) !== undefined; i++) {
            var func = f.func;
            var result = null;
            try {
                result = func(argv, aliases);
            } catch (err) {
                usage.fail(err.message ? err.message : err, err);
                continue;
            }
            if (!result) {
                usage.fail(__('Argument check failed: %s', func.toString()));
            } else if (typeof result === 'string' || result instanceof Error) {
                usage.fail(result.toString(), result);
            }
        }
    };
    var implied = {};
    self.implies = function implies(key, value) {
        argsert('<string|object> [array|number|string]', [key, value], arguments.length);
        if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
            Object.keys(key).forEach(function (k) {
                self.implies(k, key[k]);
            });
        } else {
            yargs.global(key);
            if (!implied[key]) {
                implied[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach(function (i) {
                    return self.implies(key, i);
                });
            } else {
                assertNotStrictEqual(value, undefined, shim);
                implied[key].push(value);
            }
        }
    };
    self.getImplied = function getImplied() {
        return implied;
    };
    function keyExists(argv, val) {
        var num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === 'number') {
            val = argv._.length >= val;
        } else if (val.match(/^--no-.+/)) {
            val = val.match(/^--no-(.+)/)[1];
            val = !argv[val];
        } else {
            val = argv[val];
        }
        return val;
    }
    self.implications = function implications(argv) {
        var implyFail = [];
        Object.keys(implied).forEach(function (key) {
            var origKey = key;
            (implied[key] || []).forEach(function (value) {
                var key = origKey;
                var origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key && !value) {
                    implyFail.push(' ' + origKey + ' -> ' + origValue);
                }
            });
        });
        if (implyFail.length) {
            var msg = __('Implications failed:') + '\n';
            implyFail.forEach(function (value) {
                msg += value;
            });
            usage.fail(msg);
        }
    };
    var conflicting = {};
    self.conflicts = function conflicts(key, value) {
        argsert('<string|object> [array|string]', [key, value], arguments.length);
        if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
            Object.keys(key).forEach(function (k) {
                self.conflicts(k, key[k]);
            });
        } else {
            yargs.global(key);
            if (!conflicting[key]) {
                conflicting[key] = [];
            }
            if (Array.isArray(value)) {
                value.forEach(function (i) {
                    return self.conflicts(key, i);
                });
            } else {
                conflicting[key].push(value);
            }
        }
    };
    self.getConflicting = function () {
        return conflicting;
    };
    self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach(function (key) {
            if (conflicting[key]) {
                conflicting[key].forEach(function (value) {
                    if (value && argv[key] !== undefined && argv[value] !== undefined) {
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                    }
                });
            }
        });
    };
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        var threshold = 3;
        potentialCommands = potentialCommands.sort(function (a, b) {
            return b.length - a.length;
        });
        var recommended = null;
        var bestDistance = Infinity;
        for (var i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
            var d = distance(cmd, candidate);
            if (d <= threshold && d < bestDistance) {
                bestDistance = d;
                recommended = candidate;
            }
        }
        if (recommended) usage.fail(__('Did you mean %s?', recommended));
    };
    self.reset = function reset(localLookup) {
        implied = objFilter(implied, function (k) {
            return !localLookup[k];
        });
        conflicting = objFilter(conflicting, function (k) {
            return !localLookup[k];
        });
        checks = checks.filter(function (c) {
            return c.global;
        });
        return self;
    };
    var frozens = [];
    self.freeze = function freeze() {
        frozens.push({
            implied: implied,
            checks: checks,
            conflicting: conflicting
        });
    };
    self.unfreeze = function unfreeze() {
        var frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        implied = frozen.implied;
        checks = frozen.checks;
        conflicting = frozen.conflicting;
    };
    return self;
}