/**
 * A test Runner that uses a {@link module:buffered-worker-pool}.
 * @module parallel-buffered-runner
 * @private
 */

'use strict';

import _regeneratorRuntime from 'babel-runtime/regenerator';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createMap;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Runner = require('../runner');
var _Runner$constants = Runner.constants,
    EVENT_RUN_BEGIN = _Runner$constants.EVENT_RUN_BEGIN,
    EVENT_RUN_END = _Runner$constants.EVENT_RUN_END;

var debug = require('debug')('mocha:parallel:parallel-buffered-runner');

var _require = require('./buffered-worker-pool'),
    BufferedWorkerPool = _require.BufferedWorkerPool;

var _global = global,
    setInterval = _global.setInterval,
    clearInterval = _global.clearInterval;

var _require2 = require('../utils'),
    createMap = _require2.createMap,
    constants = _require2.constants;

var MOCHA_ID_PROP_NAME = constants.MOCHA_ID_PROP_NAME;

var _require3 = require('../errors'),
    createFatalError = _require3.createFatalError;

var DEFAULT_WORKER_REPORTER = require.resolve('./reporters/parallel-buffered');

/**
 * List of options to _not_ serialize for transmission to workers
 */
var DENY_OPTIONS = ['globalSetup', 'globalTeardown', 'parallel', 'p', 'jobs', 'j'];

/**
 * Outputs a debug statement with worker stats
 * @param {BufferedWorkerPool} pool - Worker pool
 */
/* istanbul ignore next */
var debugStats = function debugStats(pool) {
  var _pool$stats = pool.stats(),
      totalWorkers = _pool$stats.totalWorkers,
      busyWorkers = _pool$stats.busyWorkers,
      idleWorkers = _pool$stats.idleWorkers,
      pendingTasks = _pool$stats.pendingTasks;

  debug('%d/%d busy workers; %d idle; %d tasks queued', busyWorkers, totalWorkers, idleWorkers, pendingTasks);
};

/**
 * The interval at which we will display stats for worker processes in debug mode
 */
var DEBUG_STATS_INTERVAL = 5000;

var ABORTED = 'ABORTED';
var IDLE = 'IDLE';
var ABORTING = 'ABORTING';
var RUNNING = 'RUNNING';
var BAILING = 'BAILING';
var BAILED = 'BAILED';
var COMPLETE = 'COMPLETE';

var states = createMap((_createMap = {}, _defineProperty(_createMap, IDLE, new Set([RUNNING, ABORTING])), _defineProperty(_createMap, RUNNING, new Set([COMPLETE, BAILING, ABORTING])), _defineProperty(_createMap, COMPLETE, new Set()), _defineProperty(_createMap, ABORTED, new Set()), _defineProperty(_createMap, ABORTING, new Set([ABORTED])), _defineProperty(_createMap, BAILING, new Set([BAILED, ABORTING])), _defineProperty(_createMap, BAILED, new Set([COMPLETE, ABORTING])), _createMap));

/**
 * This `Runner` delegates tests runs to worker threads.  Does not execute any
 * {@link Runnable}s by itself!
 * @public
 */

var ParallelBufferedRunner = function (_Runner) {
  _inherits(ParallelBufferedRunner, _Runner);

  function ParallelBufferedRunner() {
    var _ref;

    _classCallCheck(this, ParallelBufferedRunner);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = ParallelBufferedRunner.__proto__ || Object.getPrototypeOf(ParallelBufferedRunner)).call.apply(_ref, [this].concat(args)));

    var state = IDLE;
    Object.defineProperty(_this, '_state', {
      get: function get() {
        return state;
      },
      set: function set(newState) {
        if (states[state].has(newState)) {
          state = newState;
        } else {
          throw new Error('invalid state transition: ' + state + ' => ' + newState);
        }
      }
    });

    _this._workerReporter = DEFAULT_WORKER_REPORTER;
    _this._linkPartialObjects = false;
    _this._linkedObjectMap = new Map();

    _this.once(Runner.constants.EVENT_RUN_END, function () {
      _this._state = COMPLETE;
    });
    return _this;
  }

  /**
   * Returns a mapping function to enqueue a file in the worker pool and return results of its execution.
   * @param {BufferedWorkerPool} pool - Worker pool
   * @param {Options} options - Mocha options
   * @returns {FileRunner} Mapping function
   * @private
   */


  _createClass(ParallelBufferedRunner, [{
    key: '_createFileRunner',
    value: function _createFileRunner(pool, options) {
      var _this2 = this;

      /**
       * Emits event and sets `BAILING` state, if necessary.
       * @param {Object} event - Event having `eventName`, maybe `data` and maybe `error`
       * @param {number} failureCount - Failure count
       */
      var emitEvent = function emitEvent(event, failureCount) {
        _this2.emit(event.eventName, event.data, event.error);
        if (_this2._state !== BAILING && event.data && event.data._bail && (failureCount || event.error)) {
          debug('run(): nonzero failure count & found bail flag');
          // we need to let the events complete for this file, as the worker
          // should run any cleanup hooks
          _this2._state = BAILING;
        }
      };

      /**
       * Given an event, recursively find any objects in its data that have ID's, and create object references to already-seen objects.
       * @param {Object} event - Event having `eventName`, maybe `data` and maybe `error`
       */
      var linkEvent = function linkEvent(event) {
        var stack = [{ parent: event, prop: 'data' }];

        var _loop = function _loop() {
          var _stack$pop = stack.pop(),
              parent = _stack$pop.parent,
              prop = _stack$pop.prop;

          var obj = parent[prop];
          var newObj = void 0;
          if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
            if (obj[MOCHA_ID_PROP_NAME]) {
              var id = obj[MOCHA_ID_PROP_NAME];
              newObj = _this2._linkedObjectMap.has(id) ? Object.assign(_this2._linkedObjectMap.get(id), obj) : obj;
              _this2._linkedObjectMap.set(id, newObj);
              parent[prop] = newObj;
            } else {
              throw createFatalError('Object missing ID received in event data', obj);
            }
          }
          Object.keys(newObj).forEach(function (key) {
            var value = obj[key];
            if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value[MOCHA_ID_PROP_NAME]) {
              stack.push({ obj: value, parent: newObj, prop: key });
            }
          });
        };

        while (stack.length) {
          _loop();
        }
      };

      return function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(file) {
          var _ref3, failureCount, events, event;

          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  debug('run(): enqueueing test file %s', file);
                  _context.prev = 1;
                  _context.next = 4;
                  return pool.run(file, options);

                case 4:
                  _ref3 = _context.sent;
                  failureCount = _ref3.failureCount;
                  events = _ref3.events;

                  if (!(_this2._state === BAILED)) {
                    _context.next = 9;
                    break;
                  }

                  return _context.abrupt('return');

                case 9:
                  debug('run(): completed run of file %s; %d failures / %d events', file, failureCount, events.length);
                  _this2.failures += failureCount; // can this ever be non-numeric?
                  event = events.shift();


                  if (_this2._linkPartialObjects) {
                    while (event) {
                      linkEvent(event);
                      emitEvent(event, failureCount);
                      event = events.shift();
                    }
                  } else {
                    while (event) {
                      emitEvent(event, failureCount);
                      event = events.shift();
                    }
                  }

                  if (!(_this2._state === BAILING)) {
                    _context.next = 18;
                    break;
                  }

                  debug('run(): terminating pool due to "bail" flag');
                  _this2._state = BAILED;
                  _context.next = 18;
                  return pool.terminate();

                case 18:
                  _context.next = 32;
                  break;

                case 20:
                  _context.prev = 20;
                  _context.t0 = _context['catch'](1);

                  if (!(_this2._state === BAILED || _this2._state === ABORTING)) {
                    _context.next = 26;
                    break;
                  }

                  debug('run(): worker pool terminated with intent; skipping file %s', file);
                  _context.next = 32;
                  break;

                case 26:
                  // this is an uncaught exception
                  debug('run(): encountered uncaught exception: %O', _context.t0);

                  if (!_this2.allowUncaught) {
                    _context.next = 31;
                    break;
                  }

                  // still have to clean up
                  _this2._state = ABORTING;
                  _context.next = 31;
                  return pool.terminate(true);

                case 31:
                  throw _context.t0;

                case 32:
                  _context.prev = 32;

                  debug('run(): done running file %s', file);
                  return _context.finish(32);

                case 35:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, _this2, [[1, 20, 32, 35]]);
        }));

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }();
    }

    /**
     * Listen on `Process.SIGINT`; terminate pool if caught.
     * Returns the listener for later call to `process.removeListener()`.
     * @param {BufferedWorkerPool} pool - Worker pool
     * @returns {SigIntListener} Listener
     * @private
     */

  }, {
    key: '_bindSigIntListener',
    value: function _bindSigIntListener(pool) {
      var _this3 = this;

      var sigIntListener = function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  debug('run(): caught a SIGINT');
                  _this3._state = ABORTING;

                  _context2.prev = 2;

                  debug('run(): force-terminating worker pool');
                  _context2.next = 6;
                  return pool.terminate(true);

                case 6:
                  _context2.next = 12;
                  break;

                case 8:
                  _context2.prev = 8;
                  _context2.t0 = _context2['catch'](2);

                  console.error('Error while attempting to force-terminate worker pool: ' + _context2.t0);
                  process.exitCode = 1;

                case 12:
                  _context2.prev = 12;

                  process.nextTick(function () {
                    debug('run(): imminent death');
                    _this3._state = ABORTED;
                    process.kill(process.pid, 'SIGINT');
                  });
                  return _context2.finish(12);

                case 15:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, _this3, [[2, 8, 12, 15]]);
        }));

        return function sigIntListener() {
          return _ref4.apply(this, arguments);
        };
      }();

      process.once('SIGINT', sigIntListener);

      return sigIntListener;
    }

    /**
     * Runs Mocha tests by creating a thread pool, then delegating work to the
     * worker threads.
     *
     * Each worker receives one file, and as workers become available, they take a
     * file from the queue and run it. The worker thread execution is treated like
     * an RPC--it returns a `Promise` containing serialized information about the
     * run.  The information is processed as it's received, and emitted to a
     * {@link Reporter}, which is likely listening for these events.
     *
     * @param {Function} callback - Called with an exit code corresponding to
     * number of test failures.
     * @param {Object} [opts] - options
     * @param {string[]} opts.files - Files to run
     * @param {Options} opts.options - command-line options
     */

  }, {
    key: 'run',
    value: function run(callback) {
      var _this4 = this;

      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          files = _ref5.files,
          _ref5$options = _ref5.options,
          options = _ref5$options === undefined ? {} : _ref5$options;

      /**
       * Listener on `Process.SIGINT` which tries to cleanly terminate the worker pool.
       */
      var sigIntListener = void 0;

      // assign the reporter the worker will use, which will be different than the
      // main process' reporter
      options = Object.assign({}, options, { reporter: this._workerReporter });

      // This function should _not_ return a `Promise`; its parent (`Runner#run`)
      // returns this instance, so this should do the same. However, we want to make
      // use of `async`/`await`, so we use this IIFE.
      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var debugInterval, pool, results;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                /**
                 * This is an interval that outputs stats about the worker pool every so often
                 */
                debugInterval = void 0;

                /**
                 * @type {BufferedWorkerPool}
                 */

                pool = void 0;
                _context3.prev = 2;

                pool = BufferedWorkerPool.create({ maxWorkers: options.jobs });

                sigIntListener = _this4._bindSigIntListener(pool);

                /* istanbul ignore next */
                debugInterval = setInterval(function () {
                  return debugStats(pool);
                }, DEBUG_STATS_INTERVAL).unref();

                // this is set for uncaught exception handling in `Runner#uncaught`
                // TODO: `Runner` should be using a state machine instead.
                _this4.started = true;
                _this4._state = RUNNING;

                _this4.emit(EVENT_RUN_BEGIN);

                options = Object.assign({}, options);
                DENY_OPTIONS.forEach(function (opt) {
                  delete options[opt];
                });

                _context3.next = 13;
                return Promise.allSettled(files.map(_this4._createFileRunner(pool, options)));

              case 13:
                results = _context3.sent;
                _context3.next = 16;
                return pool.terminate();

              case 16:

                results.filter(function (_ref7) {
                  var status = _ref7.status;
                  return status === 'rejected';
                }).forEach(function (_ref8) {
                  var reason = _ref8.reason;

                  if (_this4.allowUncaught) {
                    // yep, just the first one.
                    throw reason;
                  }
                  // "rejected" will correspond to uncaught exceptions.
                  // unlike the serial runner, the parallel runner can always recover.
                  _this4.uncaught(reason);
                });

                if (!(_this4._state === ABORTING)) {
                  _context3.next = 19;
                  break;
                }

                return _context3.abrupt('return');

              case 19:

                _this4.emit(EVENT_RUN_END);
                debug('run(): completing with failure count %d', _this4.failures);
                callback(_this4.failures);
                _context3.next = 27;
                break;

              case 24:
                _context3.prev = 24;
                _context3.t0 = _context3['catch'](2);

                // this `nextTick` takes us out of the `Promise` scope, so the
                // exception will not be caught and returned as a rejected `Promise`,
                // which would lead to an `unhandledRejection` event.
                process.nextTick(function () {
                  debug('run(): re-throwing uncaught exception');
                  throw _context3.t0;
                });

              case 27:
                _context3.prev = 27;

                clearInterval(debugInterval);
                process.removeListener('SIGINT', sigIntListener);
                return _context3.finish(27);

              case 31:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, _this4, [[2, 24, 27, 31]]);
      }))();
      return this;
    }

    /**
     * Toggle partial object linking behavior; used for building object references from
     * unique ID's.
     * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable
     * @returns {Runner}
     * @chainable
     * @public
     * @example
     * // this reporter needs proper object references when run in parallel mode
     * class MyReporter() {
     *   constructor(runner) {
     *     this.runner.linkPartialObjects(true)
     *       .on(EVENT_SUITE_BEGIN, suite => {
               // this Suite may be the same object...
    *       })
    *       .on(EVENT_TEST_BEGIN, test => {
    *         // ...as the `test.parent` property
    *       });
    *   }
    * }
    */

  }, {
    key: 'linkPartialObjects',
    value: function linkPartialObjects(value) {
      this._linkPartialObjects = Boolean(value);
      return _get(ParallelBufferedRunner.prototype.__proto__ || Object.getPrototypeOf(ParallelBufferedRunner.prototype), 'linkPartialObjects', this).call(this, value);
    }

    /**
     * If this class is the `Runner` in use, then this is going to return `true`.
     *
     * For use by reporters.
     * @returns {true}
     * @public
     */

  }, {
    key: 'isParallelMode',
    value: function isParallelMode() {
      return true;
    }

    /**
     * Configures an alternate reporter for worker processes to use. Subclasses
     * using worker processes should implement this.
     * @public
     * @param {string} path - Absolute path to alternate reporter for worker processes to use
     * @returns {Runner}
     * @throws When in serial mode
     * @chainable
     */

  }, {
    key: 'workerReporter',
    value: function workerReporter(reporter) {
      this._workerReporter = reporter;
      return this;
    }
  }]);

  return ParallelBufferedRunner;
}(Runner);

module.exports = ParallelBufferedRunner;

/**
 * Listener function intended to be bound to `Process.SIGINT` event
 * @private
 * @callback SigIntListener
 * @returns {Promise<void>}
 */

/**
 * A function accepting a test file path and returning the results of a test run
 * @private
 * @callback FileRunner
 * @param {string} filename - File to run
 * @returns {Promise<SerializedWorkerResult>}
 */