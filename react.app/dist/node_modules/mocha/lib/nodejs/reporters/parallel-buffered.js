/**
 * "Buffered" reporter used internally by a worker process when running in parallel mode.
 * @module nodejs/reporters/parallel-buffered
 * @public
 */

'use strict';

/**
 * Module dependencies.
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require$constants = require('../../runner').constants,
    EVENT_SUITE_BEGIN = _require$constants.EVENT_SUITE_BEGIN,
    EVENT_SUITE_END = _require$constants.EVENT_SUITE_END,
    EVENT_TEST_FAIL = _require$constants.EVENT_TEST_FAIL,
    EVENT_TEST_PASS = _require$constants.EVENT_TEST_PASS,
    EVENT_TEST_PENDING = _require$constants.EVENT_TEST_PENDING,
    EVENT_TEST_BEGIN = _require$constants.EVENT_TEST_BEGIN,
    EVENT_TEST_END = _require$constants.EVENT_TEST_END,
    EVENT_TEST_RETRY = _require$constants.EVENT_TEST_RETRY,
    EVENT_DELAY_BEGIN = _require$constants.EVENT_DELAY_BEGIN,
    EVENT_DELAY_END = _require$constants.EVENT_DELAY_END,
    EVENT_HOOK_BEGIN = _require$constants.EVENT_HOOK_BEGIN,
    EVENT_HOOK_END = _require$constants.EVENT_HOOK_END,
    EVENT_RUN_END = _require$constants.EVENT_RUN_END;

var _require = require('../serializer'),
    SerializableEvent = _require.SerializableEvent,
    SerializableWorkerResult = _require.SerializableWorkerResult;

var debug = require('debug')('mocha:reporters:buffered');
var Base = require('../../reporters/base');

/**
 * List of events to listen to; these will be buffered and sent
 * when `Mocha#run` is complete (via {@link ParallelBuffered#done}).
 */
var EVENT_NAMES = [EVENT_SUITE_BEGIN, EVENT_SUITE_END, EVENT_TEST_BEGIN, EVENT_TEST_PENDING, EVENT_TEST_FAIL, EVENT_TEST_PASS, EVENT_TEST_RETRY, EVENT_TEST_END, EVENT_HOOK_BEGIN, EVENT_HOOK_END];

/**
 * Like {@link EVENT_NAMES}, except we expect these events to only be emitted
 * by the `Runner` once.
 */
var ONCE_EVENT_NAMES = [EVENT_DELAY_BEGIN, EVENT_DELAY_END];

/**
 * The `ParallelBuffered` reporter is used by each worker process in "parallel"
 * mode, by default.  Instead of reporting to to `STDOUT`, etc., it retains a
 * list of events it receives and hands these off to the callback passed into
 * {@link Mocha#run}. That callback will then return the data to the main
 * process.
 * @public
 */

var ParallelBuffered = function (_Base) {
  _inherits(ParallelBuffered, _Base);

  /**
   * Calls {@link ParallelBuffered#createListeners}
   * @param {Runner} runner
   */
  function ParallelBuffered(runner, opts) {
    _classCallCheck(this, ParallelBuffered);

    /**
     * Retained list of events emitted from the {@link Runner} instance.
     * @type {BufferedEvent[]}
     * @public
     */
    var _this = _possibleConstructorReturn(this, (ParallelBuffered.__proto__ || Object.getPrototypeOf(ParallelBuffered)).call(this, runner, opts));

    _this.events = [];

    /**
     * Map of `Runner` event names to listeners (for later teardown)
     * @public
     * @type {Map<string,EventListener>}
     */
    _this.listeners = new Map();

    _this.createListeners(runner);
    return _this;
  }

  /**
   * Returns a new listener which saves event data in memory to
   * {@link ParallelBuffered#events}. Listeners are indexed by `eventName` and stored
   * in {@link ParallelBuffered#listeners}. This is a defensive measure, so that we
   * don't a) leak memory or b) remove _other_ listeners that may not be
   * associated with this reporter.
   *
   * Subclasses could override this behavior.
   *
   * @public
   * @param {string} eventName - Name of event to create listener for
   * @returns {EventListener}
   */


  _createClass(ParallelBuffered, [{
    key: 'createListener',
    value: function createListener(eventName) {
      var _this2 = this;

      var listener = function listener(runnable, err) {
        _this2.events.push(SerializableEvent.create(eventName, runnable, err));
      };
      return this.listeners.set(eventName, listener).get(eventName);
    }

    /**
     * Creates event listeners (using {@link ParallelBuffered#createListener}) for each
     * reporter-relevant event emitted by a {@link Runner}. This array is drained when
     * {@link ParallelBuffered#done} is called by {@link Runner#run}.
     *
     * Subclasses could override this behavior.
     * @public
     * @param {Runner} runner - Runner instance
     * @returns {ParallelBuffered}
     * @chainable
     */

  }, {
    key: 'createListeners',
    value: function createListeners(runner) {
      var _this3 = this;

      EVENT_NAMES.forEach(function (evt) {
        runner.on(evt, _this3.createListener(evt));
      });
      ONCE_EVENT_NAMES.forEach(function (evt) {
        runner.once(evt, _this3.createListener(evt));
      });

      runner.once(EVENT_RUN_END, function () {
        debug('received EVENT_RUN_END');
        _this3.listeners.forEach(function (listener, evt) {
          runner.removeListener(evt, listener);
          _this3.listeners.delete(evt);
        });
      });

      return this;
    }

    /**
     * Calls the {@link Mocha#run} callback (`callback`) with the test failure
     * count and the array of {@link BufferedEvent} objects. Resets the array.
     *
     * This is called directly by `Runner#run` and should not be called by any other consumer.
     *
     * Subclasses could override this.
     *
     * @param {number} failures - Number of failed tests
     * @param {Function} callback - The callback passed to {@link Mocha#run}.
     * @public
     */

  }, {
    key: 'done',
    value: function done(failures, callback) {
      callback(SerializableWorkerResult.create(this.events, failures));
      this.events = []; // defensive
    }
  }]);

  return ParallelBuffered;
}(Base);

/**
 * Serializable event data from a `Runner`.  Keys of the `data` property
 * beginning with `__` will be converted into a function which returns the value
 * upon deserialization.
 * @typedef {Object} BufferedEvent
 * @property {string} name - Event name
 * @property {object} data - Event parameters
 */

module.exports = ParallelBuffered;