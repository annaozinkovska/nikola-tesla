/**
 * A wrapper around a third-party child process worker pool implementation.
 * Used by {@link module:buffered-runner}.
 * @private
 * @module buffered-worker-pool
 */

'use strict';

import _regeneratorRuntime from 'babel-runtime/regenerator';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var serializeJavascript = require('serialize-javascript');
var workerpool = require('workerpool');

var _require = require('./serializer'),
    deserialize = _require.deserialize;

var debug = require('debug')('mocha:parallel:buffered-worker-pool');

var _require2 = require('../errors'),
    createInvalidArgumentTypeError = _require2.createInvalidArgumentTypeError;

var WORKER_PATH = require.resolve('./worker.js');

/**
 * A mapping of Mocha `Options` objects to serialized values.
 *
 * This is helpful because we tend to same the same options over and over
 * over IPC.
 * @type {WeakMap<Options,string>}
 */
var optionsCache = new WeakMap();

/**
 * These options are passed into the [workerpool](https://npm.im/workerpool) module.
 * @type {Partial<WorkerPoolOptions>}
 */
var WORKER_POOL_DEFAULT_OPTS = {
  // use child processes, not worker threads!
  workerType: 'process',
  // ensure the same flags sent to `node` for this `mocha` invocation are passed
  // along to children
  forkOpts: { execArgv: process.execArgv },
  maxWorkers: workerpool.cpus - 1
};

/**
 * A wrapper around a third-party worker pool implementation.
 * @private
 */

var BufferedWorkerPool = function () {
  /**
   * Creates an underlying worker pool instance; determines max worker count
   * @param {Partial<WorkerPoolOptions>} [opts] - Options
   */
  function BufferedWorkerPool() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BufferedWorkerPool);

    var maxWorkers = Math.max(1, typeof opts.maxWorkers === 'undefined' ? WORKER_POOL_DEFAULT_OPTS.maxWorkers : opts.maxWorkers);

    /* istanbul ignore next */
    if (workerpool.cpus < 2) {
      // TODO: decide whether we should warn
      debug('not enough CPU cores available to run multiple jobs; avoid --parallel on this machine');
    } else if (maxWorkers >= workerpool.cpus) {
      // TODO: decide whether we should warn
      debug('%d concurrent job(s) requested, but only %d core(s) available', maxWorkers, workerpool.cpus);
    }
    /* istanbul ignore next */
    debug('run(): starting worker pool of max size %d, using node args: %s', maxWorkers, process.execArgv.join(' '));

    var counter = 0;
    var onCreateWorker = function onCreateWorker(_ref) {
      var forkOpts = _ref.forkOpts;

      return {
        forkOpts: Object.assign({}, forkOpts, {
          // adds an incremental id to all workers, which can be useful to allocate resources for each process
          env: Object.assign({}, process.env, { MOCHA_WORKER_ID: counter++ })
        })
      };
    };

    this.options = Object.assign({}, WORKER_POOL_DEFAULT_OPTS, opts, {
      maxWorkers: maxWorkers,
      onCreateWorker: onCreateWorker
    });
    this._pool = workerpool.pool(WORKER_PATH, this.options);
  }

  /**
   * Terminates all workers in the pool.
   * @param {boolean} [force] - Whether to force-kill workers. By default, lets workers finish their current task before termination.
   * @private
   * @returns {Promise<void>}
   */


  _createClass(BufferedWorkerPool, [{
    key: 'terminate',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                /* istanbul ignore next */
                debug('terminate(): terminating with force = %s', force);
                return _context.abrupt('return', this._pool.terminate(force));

              case 2:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function terminate() {
        return _ref2.apply(this, arguments);
      }

      return terminate;
    }()

    /**
     * Adds a test file run to the worker pool queue for execution by a worker process.
     *
     * Handles serialization/deserialization.
     *
     * @param {string} filepath - Filepath of test
     * @param {Options} [options] - Options for Mocha instance
     * @private
     * @returns {Promise<SerializedWorkerResult>}
     */

  }, {
    key: 'run',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(filepath) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var serializedOptions, result;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(!filepath || typeof filepath !== 'string')) {
                  _context2.next = 2;
                  break;
                }

                throw createInvalidArgumentTypeError('Expected a non-empty filepath', 'filepath', 'string');

              case 2:
                serializedOptions = BufferedWorkerPool.serializeOptions(options);
                _context2.next = 5;
                return this._pool.exec('run', [filepath, serializedOptions]);

              case 5:
                result = _context2.sent;
                return _context2.abrupt('return', deserialize(result));

              case 7:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function run(_x4) {
        return _ref3.apply(this, arguments);
      }

      return run;
    }()

    /**
     * Returns stats about the state of the worker processes in the pool.
     *
     * Used for debugging.
     *
     * @private
     */

  }, {
    key: 'stats',
    value: function stats() {
      return this._pool.stats();
    }

    /**
     * Instantiates a {@link WorkerPool}.
     * @private
     */

  }], [{
    key: 'create',
    value: function create() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new (Function.prototype.bind.apply(BufferedWorkerPool, [null].concat(args)))();
    }

    /**
     * Given Mocha options object `opts`, serialize into a format suitable for
     * transmission over IPC.
     *
     * @param {Options} [opts] - Mocha options
     * @private
     * @returns {string} Serialized options
     */

  }, {
    key: 'serializeOptions',
    value: function serializeOptions() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!optionsCache.has(opts)) {
        var serialized = serializeJavascript(opts, {
          unsafe: true, // this means we don't care about XSS
          ignoreFunction: true // do not serialize functions
        });
        optionsCache.set(opts, serialized);
        /* istanbul ignore next */
        debug('serializeOptions(): serialized options %O to: %s', opts, serialized);
      }
      return optionsCache.get(opts);
    }

    /**
     * Resets internal cache of serialized options objects.
     *
     * For testing/debugging
     * @private
     */

  }, {
    key: 'resetOptionsCache',
    value: function resetOptionsCache() {
      optionsCache = new WeakMap();
    }
  }]);

  return BufferedWorkerPool;
}();

exports.BufferedWorkerPool = BufferedWorkerPool;