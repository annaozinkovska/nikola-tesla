/**
 * Serialization/deserialization classes and functions for communication between a main Mocha process and worker processes.
 * @module serializer
 * @private
 */

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('../utils'),
    type = _require.type;

var _require2 = require('../errors'),
    createInvalidArgumentTypeError = _require2.createInvalidArgumentTypeError;
// this is not named `mocha:parallel:serializer` because it's noisy and it's
// helpful to be able to write `DEBUG=mocha:parallel*` and get everything else.


var debug = require('debug')('mocha:serializer');

var SERIALIZABLE_RESULT_NAME = 'SerializableWorkerResult';
var SERIALIZABLE_TYPES = new Set(['object', 'array', 'function', 'error']);

/**
 * The serializable result of a test file run from a worker.
 * @private
 */

var SerializableWorkerResult = function () {
  /**
   * Creates instance props; of note, the `__type` prop.
   *
   * Note that the failure count is _redundant_ and could be derived from the
   * list of events; but since we're already doing the work, might as well use
   * it.
   * @param {SerializableEvent[]} [events=[]] - Events to eventually serialize
   * @param {number} [failureCount=0] - Failure count
   */
  function SerializableWorkerResult() {
    var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var failureCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, SerializableWorkerResult);

    /**
     * The number of failures in this run
     * @type {number}
     */
    this.failureCount = failureCount;
    /**
     * All relevant events emitted from the {@link Runner}.
     * @type {SerializableEvent[]}
     */
    this.events = events;

    /**
     * Symbol-like value needed to distinguish when attempting to deserialize
     * this object (once it's been received over IPC).
     * @type {Readonly<"SerializableWorkerResult">}
     */
    Object.defineProperty(this, '__type', {
      value: SERIALIZABLE_RESULT_NAME,
      enumerable: true,
      writable: false
    });
  }

  /**
   * Instantiates a new {@link SerializableWorkerResult}.
   * @param {...any} args - Args to constructor
   * @returns {SerializableWorkerResult}
   */


  _createClass(SerializableWorkerResult, [{
    key: 'serialize',


    /**
     * Serializes each {@link SerializableEvent} in our `events` prop;
     * makes this object read-only.
     * @returns {Readonly<SerializableWorkerResult>}
     */
    value: function serialize() {
      this.events.forEach(function (event) {
        event.serialize();
      });
      return Object.freeze(this);
    }

    /**
     * Deserializes a {@link SerializedWorkerResult} into something reporters can
     * use; calls {@link SerializableEvent.deserialize} on each item in its
     * `events` prop.
     * @param {SerializedWorkerResult} obj
     * @returns {SerializedWorkerResult}
     */

  }], [{
    key: 'create',
    value: function create() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new (Function.prototype.bind.apply(SerializableWorkerResult, [null].concat(args)))();
    }
  }, {
    key: 'deserialize',
    value: function deserialize(obj) {
      obj.events.forEach(function (event) {
        SerializableEvent.deserialize(event);
      });
      return obj;
    }

    /**
     * Returns `true` if this is a {@link SerializedWorkerResult} or a
     * {@link SerializableWorkerResult}.
     * @param {*} value - A value to check
     * @returns {boolean} If true, it's deserializable
     */

  }, {
    key: 'isSerializedWorkerResult',
    value: function isSerializedWorkerResult(value) {
      return value instanceof SerializableWorkerResult || type(value) === 'object' && value.__type === SERIALIZABLE_RESULT_NAME;
    }
  }]);

  return SerializableWorkerResult;
}();

/**
 * Represents an event, emitted by a {@link Runner}, which is to be transmitted
 * over IPC.
 *
 * Due to the contents of the event data, it's not possible to send them
 * verbatim. When received by the main process--and handled by reporters--these
 * objects are expected to contain {@link Runnable} instances.  This class
 * provides facilities to perform the translation via serialization and
 * deserialization.
 * @private
 */


var SerializableEvent = function () {
  /**
   * Constructs a `SerializableEvent`, throwing if we receive unexpected data.
   *
   * Practically, events emitted from `Runner` have a minumum of zero (0)
   * arguments-- (for example, {@link Runnable.constants.EVENT_RUN_BEGIN}) and a
   * maximum of two (2) (for example,
   * {@link Runnable.constants.EVENT_TEST_FAIL}, where the second argument is an
   * `Error`).  The first argument, if present, is a {@link Runnable}. This
   * constructor's arguments adhere to this convention.
   * @param {string} eventName - A non-empty event name.
   * @param {any} [originalValue] - Some data. Corresponds to extra arguments
   * passed to `EventEmitter#emit`.
   * @param {Error} [originalError] - An error, if there's an error.
   * @throws If `eventName` is empty, or `originalValue` is a non-object.
   */
  function SerializableEvent(eventName, originalValue, originalError) {
    _classCallCheck(this, SerializableEvent);

    if (!eventName) {
      throw createInvalidArgumentTypeError('Empty `eventName` string argument', 'eventName', 'string');
    }
    /**
     * The event name.
     * @memberof SerializableEvent
     */
    this.eventName = eventName;
    var originalValueType = type(originalValue);
    if (originalValueType !== 'object' && originalValueType !== 'undefined') {
      throw createInvalidArgumentTypeError('Expected object but received ' + originalValueType, 'originalValue', 'object');
    }
    /**
     * An error, if present.
     * @memberof SerializableEvent
     */
    Object.defineProperty(this, 'originalError', {
      value: originalError,
      enumerable: false
    });

    /**
     * The raw value.
     *
     * We don't want this value sent via IPC; making it non-enumerable will do that.
     *
     * @memberof SerializableEvent
     */
    Object.defineProperty(this, 'originalValue', {
      value: originalValue,
      enumerable: false
    });
  }

  /**
   * In case you hated using `new` (I do).
   *
   * @param  {...any} args - Args for {@link SerializableEvent#constructor}.
   * @returns {SerializableEvent} A new `SerializableEvent`
   */


  _createClass(SerializableEvent, [{
    key: 'serialize',


    /**
     * Modifies this object *in place* (for theoretical memory consumption &
     * performance reasons); serializes `SerializableEvent#originalValue` (placing
     * the result in `SerializableEvent#data`) and `SerializableEvent#error`.
     * Freezes this object. The result is an object that can be transmitted over
     * IPC.
     * If this quickly becomes unmaintainable, we will want to move towards immutable
     * objects post-haste.
     */
    value: function serialize() {
      // given a parent object and a key, inspect the value and decide whether
      // to replace it, remove it, or add it to our `pairs` array to further process.
      // this is recursion in loop form.
      var originalValue = this.originalValue;
      var result = Object.assign(Object.create(null), {
        data: type(originalValue) === 'object' && type(originalValue.serialize) === 'function' ? originalValue.serialize() : originalValue,
        error: this.originalError
      });

      var pairs = Object.keys(result).map(function (key) {
        return [result, key];
      });
      var seenObjects = new WeakSet();

      var pair = void 0;
      while (pair = pairs.shift()) {
        SerializableEvent._serialize.apply(SerializableEvent, [pairs].concat(_toConsumableArray(pair), [seenObjects]));
        seenObjects.add(pair[0]);
      }

      this.data = result.data;
      this.error = result.error;

      return Object.freeze(this);
    }

    /**
     * Used internally by {@link SerializableEvent.deserialize}; creates an `Error`
     * from an `Error`-like (serialized) object
     * @ignore
     * @param {Object} value - An Error-like value
     * @returns {Error} Real error
     */

  }], [{
    key: 'create',
    value: function create() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return new (Function.prototype.bind.apply(SerializableEvent, [null].concat(args)))();
    }

    /**
     * Used internally by {@link SerializableEvent#serialize}.
     * @ignore
     * @param {Array<object|string>} pairs - List of parent/key tuples to process; modified in-place. This JSDoc type is an approximation
     * @param {object} parent - Some parent object
     * @param {string} key - Key to inspect
     * @param {WeakSet<Object>} seenObjects - For avoiding circular references
     */

  }, {
    key: '_serialize',
    value: function _serialize(pairs, parent, key, seenObjects) {
      var value = parent[key];
      if (seenObjects.has(value)) {
        parent[key] = Object.create(null);
        return;
      }
      var _type = type(value);
      if (_type === 'error') {
        // we need to reference the stack prop b/c it's lazily-loaded.
        // `__type` is necessary for deserialization to create an `Error` later.
        // `message` is apparently not enumerable, so we must handle it specifically.
        value = Object.assign(Object.create(null), value, {
          stack: value.stack,
          message: value.message,
          __type: 'Error'
        });
        parent[key] = value;
        // after this, set the result of type(value) to be `object`, and we'll throw
        // whatever other junk is in the original error into the new `value`.
        _type = 'object';
      }
      switch (_type) {
        case 'object':
          if (type(value.serialize) === 'function') {
            parent[key] = value.serialize();
          } else {
            // by adding props to the `pairs` array, we will process it further
            pairs.push.apply(pairs, _toConsumableArray(Object.keys(value).filter(function (key) {
              return SERIALIZABLE_TYPES.has(type(value[key]));
            }).map(function (key) {
              return [value, key];
            })));
          }
          break;
        case 'function':
          // we _may_ want to dig in to functions for some assertion libraries
          // that might put a usable property on a function.
          // for now, just zap it.
          delete parent[key];
          break;
        case 'array':
          pairs.push.apply(pairs, _toConsumableArray(value.filter(function (value) {
            return SERIALIZABLE_TYPES.has(type(value));
          }).map(function (value, index) {
            return [value, index];
          })));
          break;
      }
    }
  }, {
    key: '_deserializeError',
    value: function _deserializeError(value) {
      var error = new Error(value.message);
      error.stack = value.stack;
      Object.assign(error, value);
      delete error.__type;
      return error;
    }

    /**
     * Used internally by {@link SerializableEvent.deserialize}; recursively
     * deserializes an object in-place.
     * @param {object|Array} parent - Some object or array
     * @param {string|number} key - Some prop name or array index within `parent`
     */

  }, {
    key: '_deserializeObject',
    value: function _deserializeObject(parent, key) {
      if (key === '__proto__') {
        delete parent[key];
        return;
      }
      var value = parent[key];
      // keys beginning with `$$` are converted into functions returning the value
      // and renamed, stripping the `$$` prefix.
      // functions defined this way cannot be array members!
      if (type(key) === 'string' && key.startsWith('$$')) {
        var newKey = key.slice(2);
        parent[newKey] = function () {
          return value;
        };
        delete parent[key];
        key = newKey;
      }
      if (type(value) === 'array') {
        value.forEach(function (_, idx) {
          SerializableEvent._deserializeObject(value, idx);
        });
      } else if (type(value) === 'object') {
        if (value.__type === 'Error') {
          parent[key] = SerializableEvent._deserializeError(value);
        } else {
          Object.keys(value).forEach(function (key) {
            SerializableEvent._deserializeObject(value, key);
          });
        }
      }
    }

    /**
     * Deserialize value returned from a worker into something more useful.
     * Does not return the same object.
     * @todo do this in a loop instead of with recursion (if necessary)
     * @param {SerializedEvent} obj - Object returned from worker
     * @returns {SerializedEvent} Deserialized result
     */

  }, {
    key: 'deserialize',
    value: function deserialize(obj) {
      if (!obj) {
        throw createInvalidArgumentTypeError('Expected value', obj);
      }

      obj = Object.assign(Object.create(null), obj);

      if (obj.data) {
        Object.keys(obj.data).forEach(function (key) {
          SerializableEvent._deserializeObject(obj.data, key);
        });
      }

      if (obj.error) {
        obj.error = SerializableEvent._deserializeError(obj.error);
      }

      return obj;
    }
  }]);

  return SerializableEvent;
}();

/**
 * "Serializes" a value for transmission over IPC as a message.
 *
 * If value is an object and has a `serialize()` method, call that method; otherwise return the object and hope for the best.
 *
 * @param {*} [value] - A value to serialize
 */


exports.serialize = function serialize(value) {
  var result = type(value) === 'object' && type(value.serialize) === 'function' ? value.serialize() : value;
  debug('serialized: %O', result);
  return result;
};

/**
 * "Deserializes" a "message" received over IPC.
 *
 * This could be expanded with other objects that need deserialization,
 * but at present time we only care about {@link SerializableWorkerResult} objects.
 *
 * @param {*} [value] - A "message" to deserialize
 */
exports.deserialize = function deserialize(value) {
  var result = SerializableWorkerResult.isSerializedWorkerResult(value) ? SerializableWorkerResult.deserialize(value) : value;
  debug('deserialized: %O', result);
  return result;
};

exports.SerializableEvent = SerializableEvent;
exports.SerializableWorkerResult = SerializableWorkerResult;

/**
 * The result of calling `SerializableEvent.serialize`, as received
 * by the deserializer.
 * @private
 * @typedef {Object} SerializedEvent
 * @property {object?} data - Optional serialized data
 * @property {object?} error - Optional serialized `Error`
 */

/**
 * The result of calling `SerializableWorkerResult.serialize` as received
 * by the deserializer.
 * @private
 * @typedef {Object} SerializedWorkerResult
 * @property {number} failureCount - Number of failures
 * @property {SerializedEvent[]} events - Serialized events
 * @property {"SerializedWorkerResult"} __type - Symbol-like to denote the type of object this is
 */