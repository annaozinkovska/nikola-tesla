'use strict';

/**
 * Main entry point for handling filesystem-based configuration,
 * whether that's a config file or `package.json` or whatever.
 * @module lib/cli/options
 * @private
 */

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var fs = require('fs');
var ansi = require('ansi-colors');
var yargsParser = require('yargs-parser');

var _require = require('./run-option-metadata'),
    types = _require.types,
    aliases = _require.aliases;

var _require2 = require('./one-and-dones'),
    ONE_AND_DONE_ARGS = _require2.ONE_AND_DONE_ARGS;

var mocharc = require('../mocharc.json');

var _require3 = require('./run-helpers'),
    list = _require3.list;

var _require4 = require('./config'),
    loadConfig = _require4.loadConfig,
    findConfig = _require4.findConfig;

var findUp = require('find-up');
var debug = require('debug')('mocha:cli:options');

var _require5 = require('./node-flags'),
    isNodeFlag = _require5.isNodeFlag;

var _require6 = require('../errors'),
    createUnparsableFileError = _require6.createUnparsableFileError;

/**
 * The `yargs-parser` namespace
 * @external yargsParser
 * @see {@link https://npm.im/yargs-parser}
 */

/**
 * An object returned by a configured `yargs-parser` representing arguments
 * @memberof external:yargsParser
 * @interface Arguments
 */

/**
 * Base yargs parser configuration
 * @private
 */


var YARGS_PARSER_CONFIG = {
  'combine-arrays': true,
  'short-option-groups': false,
  'dot-notation': false,
  'strip-aliased': true
};

/**
 * This is the config pulled from the `yargs` property of Mocha's
 * `package.json`, but it also disables camel case expansion as to
 * avoid outputting non-canonical keynames, as we need to do some
 * lookups.
 * @private
 * @ignore
 */
var configuration = Object.assign({}, YARGS_PARSER_CONFIG, {
  'camel-case-expansion': false
});

/**
 * This is a really fancy way to:
 * - `array`-type options: ensure unique values and evtl. split comma-delimited lists
 * - `boolean`/`number`/`string`- options: use last element when given multiple times
 * This is passed as the `coerce` option to `yargs-parser`
 * @private
 * @ignore
 */
var globOptions = ['spec', 'ignore'];
var coerceOpts = Object.assign(types.array.reduce(function (acc, arg) {
  return Object.assign(acc, _defineProperty({}, arg, function (v) {
    return Array.from(new Set(globOptions.includes(arg) ? v : list(v)));
  }));
}, {}), types.boolean.concat(types.string, types.number).reduce(function (acc, arg) {
  return Object.assign(acc, _defineProperty({}, arg, function (v) {
    return Array.isArray(v) ? v.pop() : v;
  }));
}, {}));

/**
 * We do not have a case when multiple arguments are ever allowed after a flag
 * (e.g., `--foo bar baz quux`), so we fix the number of arguments to 1 across
 * the board of non-boolean options.
 * This is passed as the `narg` option to `yargs-parser`
 * @private
 * @ignore
 */
var nargOpts = types.array.concat(types.string, types.number).reduce(function (acc, arg) {
  return Object.assign(acc, _defineProperty({}, arg, 1));
}, {});

/**
 * Wrapper around `yargs-parser` which applies our settings
 * @param {string|string[]} args - Arguments to parse
 * @param {Object} defaultValues - Default values of mocharc.json
 * @param  {...Object} configObjects - `configObjects` for yargs-parser
 * @private
 * @ignore
 */
var parse = function parse() {
  for (var _len = arguments.length, configObjects = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    configObjects[_key - 2] = arguments[_key];
  }

  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var defaultValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // save node-specific args for special handling.
  // 1. when these args have a "=" they should be considered to have values
  // 2. if they don't, they just boolean flags
  // 3. to avoid explicitly defining the set of them, we tell yargs-parser they
  //    are ALL boolean flags.
  // 4. we can then reapply the values after yargs-parser is done.
  var nodeArgs = (Array.isArray(args) ? args : args.split(' ')).reduce(function (acc, arg) {
    var pair = arg.split('=');
    var flag = pair[0];
    if (isNodeFlag(flag, false)) {
      flag = flag.replace(/^--?/, '');
      return arg.includes('=') ? acc.concat([[flag, pair[1]]]) : acc.concat([[flag, true]]);
    }
    return acc;
  }, []);

  var result = yargsParser.detailed(args, {
    configuration: configuration,
    configObjects: configObjects,
    default: defaultValues,
    coerce: coerceOpts,
    narg: nargOpts,
    alias: aliases,
    string: types.string,
    array: types.array,
    number: types.number,
    boolean: types.boolean.concat(nodeArgs.map(function (pair) {
      return pair[0];
    }))
  });
  if (result.error) {
    console.error(ansi.red('Error: ' + result.error.message));
    process.exit(1);
  }

  // reapply "=" arg values from above
  nodeArgs.forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    result.argv[key] = value;
  });

  return result.argv;
};

/**
 * Given path to config file in `args.config`, attempt to load & parse config file.
 * @param {Object} [args] - Arguments object
 * @param {string|boolean} [args.config] - Path to config file or `false` to skip
 * @public
 * @alias module:lib/cli.loadRc
 * @returns {external:yargsParser.Arguments|void} Parsed config, or nothing if `args.config` is `false`
 */
var loadRc = function loadRc() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (args.config !== false) {
    var config = args.config || findConfig();
    return config ? loadConfig(config) : {};
  }
};

module.exports.loadRc = loadRc;

/**
 * Given path to `package.json` in `args.package`, attempt to load config from `mocha` prop.
 * @param {Object} [args] - Arguments object
 * @param {string|boolean} [args.config] - Path to `package.json` or `false` to skip
 * @public
 * @alias module:lib/cli.loadPkgRc
 * @returns {external:yargsParser.Arguments|void} Parsed config, or nothing if `args.package` is `false`
 */
var loadPkgRc = function loadPkgRc() {
  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var result = void 0;
  if (args.package === false) {
    return result;
  }
  result = {};
  var filepath = args.package || findUp.sync(mocharc.package);
  if (filepath) {
    try {
      var pkg = JSON.parse(fs.readFileSync(filepath, 'utf8'));
      if (pkg.mocha) {
        debug('`mocha` prop of package.json parsed: %O', pkg.mocha);
        result = pkg.mocha;
      } else {
        debug('no config found in %s', filepath);
      }
    } catch (err) {
      if (args.package) {
        throw createUnparsableFileError('Unable to read/parse ' + filepath + ': ' + err, filepath);
      }
      debug('failed to read default package.json at %s; ignoring', filepath);
    }
  }
  return result;
};

module.exports.loadPkgRc = loadPkgRc;

/**
 * Priority list:
 *
 * 1. Command-line args
 * 2. RC file (`.mocharc.c?js`, `.mocharc.ya?ml`, `mocharc.json`)
 * 3. `mocha` prop of `package.json`
 * 4. default configuration (`lib/mocharc.json`)
 *
 * If a {@link module:lib/cli/one-and-dones.ONE_AND_DONE_ARGS "one-and-done" option} is present in the `argv` array, no external config files will be read.
 * @summary Parses options read from `.mocharc.*` and `package.json`.
 * @param {string|string[]} [argv] - Arguments to parse
 * @public
 * @alias module:lib/cli.loadOptions
 * @returns {external:yargsParser.Arguments} Parsed args from everything
 */
var loadOptions = function loadOptions() {
  var argv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var args = parse(argv);
  // short-circuit: look for a flag that would abort loading of options
  if (Array.from(ONE_AND_DONE_ARGS).reduce(function (acc, arg) {
    return acc || arg in args;
  }, false)) {
    return args;
  }

  var rcConfig = loadRc(args);
  var pkgConfig = loadPkgRc(args);

  if (rcConfig) {
    args.config = false;
    args._ = args._.concat(rcConfig._ || []);
  }
  if (pkgConfig) {
    args.package = false;
    args._ = args._.concat(pkgConfig._ || []);
  }

  args = parse(args._, mocharc, args, rcConfig || {}, pkgConfig || {});

  // recombine positional arguments and "spec"
  if (args.spec) {
    args._ = args._.concat(args.spec);
    delete args.spec;
  }

  // make unique
  args._ = Array.from(new Set(args._));

  return args;
};

module.exports.loadOptions = loadOptions;
module.exports.YARGS_PARSER_CONFIG = YARGS_PARSER_CONFIG;