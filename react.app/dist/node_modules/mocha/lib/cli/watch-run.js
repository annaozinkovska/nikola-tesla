'use strict';

import _regeneratorRuntime from 'babel-runtime/regenerator';

var _this = this;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var logSymbols = require('log-symbols');
var debug = require('debug')('mocha:cli:watch');
var path = require('path');
var chokidar = require('chokidar');
var Context = require('../context');
var collectFiles = require('./collect-files');

/**
 * Exports the `watchRun` function that runs mocha in "watch" mode.
 * @see module:lib/cli/run-helpers
 * @module
 * @private
 */

/**
 * Run Mocha in parallel "watch" mode
 * @param {Mocha} mocha - Mocha instance
 * @param {Object} opts - Options
 * @param {string[]} [opts.watchFiles] - List of paths and patterns to
 *   watch. If not provided all files with an extension included in
 *   `fileCollectionParams.extension` are watched. See first argument of
 *   `chokidar.watch`.
 * @param {string[]} opts.watchIgnore - List of paths and patterns to
 *   exclude from watching. See `ignored` option of `chokidar`.
 * @param {FileCollectionOptions} fileCollectParams - Parameters that control test
 * @private
 */
exports.watchParallelRun = function (mocha, _ref, fileCollectParams) {
  var watchFiles = _ref.watchFiles,
      watchIgnore = _ref.watchIgnore;

  debug('creating parallel watcher');

  return createWatcher(mocha, {
    watchFiles: watchFiles,
    watchIgnore: watchIgnore,
    beforeRun: function beforeRun(_ref2) {
      var mocha = _ref2.mocha;

      // I don't know why we're cloning the root suite.
      var rootSuite = mocha.suite.clone();

      // ensure we aren't leaking event listeners
      mocha.dispose();

      // this `require` is needed because the require cache has been cleared.  the dynamic
      // exports set via the below call to `mocha.ui()` won't work properly if a
      // test depends on this module.
      var Mocha = require('../mocha');

      // ... and now that we've gotten a new module, we need to use it again due
      // to `mocha.ui()` call
      var newMocha = new Mocha(mocha.options);
      // don't know why this is needed
      newMocha.suite = rootSuite;
      // nor this
      newMocha.suite.ctx = new Context();

      // reset the list of files
      newMocha.files = collectFiles(fileCollectParams);

      // because we've swapped out the root suite (see the `run` inner function
      // in `createRerunner`), we need to call `mocha.ui()` again to set up the context/globals.
      newMocha.ui(newMocha.options.ui);

      // we need to call `newMocha.rootHooks` to set up rootHooks for the new
      // suite
      newMocha.rootHooks(newMocha.options.rootHooks);

      // in parallel mode, the main Mocha process doesn't actually load the
      // files. this flag prevents `mocha.run()` from autoloading.
      newMocha.lazyLoadFiles(true);
      return newMocha;
    },

    fileCollectParams: fileCollectParams
  });
};

/**
 * Run Mocha in "watch" mode
 * @param {Mocha} mocha - Mocha instance
 * @param {Object} opts - Options
 * @param {string[]} [opts.watchFiles] - List of paths and patterns to
 *   watch. If not provided all files with an extension included in
 *   `fileCollectionParams.extension` are watched. See first argument of
 *   `chokidar.watch`.
 * @param {string[]} opts.watchIgnore - List of paths and patterns to
 *   exclude from watching. See `ignored` option of `chokidar`.
 * @param {FileCollectionOptions} fileCollectParams - Parameters that control test
 *   file collection. See `lib/cli/collect-files.js`.
 * @private
 */
exports.watchRun = function (mocha, _ref3, fileCollectParams) {
  var watchFiles = _ref3.watchFiles,
      watchIgnore = _ref3.watchIgnore;

  debug('creating serial watcher');

  return createWatcher(mocha, {
    watchFiles: watchFiles,
    watchIgnore: watchIgnore,
    beforeRun: function beforeRun(_ref4) {
      var mocha = _ref4.mocha;

      mocha.unloadFiles();

      // I don't know why we're cloning the root suite.
      var rootSuite = mocha.suite.clone();

      // ensure we aren't leaking event listeners
      mocha.dispose();

      // this `require` is needed because the require cache has been cleared.  the dynamic
      // exports set via the below call to `mocha.ui()` won't work properly if a
      // test depends on this module.
      var Mocha = require('../mocha');

      // ... and now that we've gotten a new module, we need to use it again due
      // to `mocha.ui()` call
      var newMocha = new Mocha(mocha.options);
      // don't know why this is needed
      newMocha.suite = rootSuite;
      // nor this
      newMocha.suite.ctx = new Context();

      // reset the list of files
      newMocha.files = collectFiles(fileCollectParams);

      // because we've swapped out the root suite (see the `run` inner function
      // in `createRerunner`), we need to call `mocha.ui()` again to set up the context/globals.
      newMocha.ui(newMocha.options.ui);

      // we need to call `newMocha.rootHooks` to set up rootHooks for the new
      // suite
      newMocha.rootHooks(newMocha.options.rootHooks);

      return newMocha;
    },

    fileCollectParams: fileCollectParams
  });
};

/**
 * Bootstraps a chokidar watcher. Handles keyboard input & signals
 * @param {Mocha} mocha - Mocha instance
 * @param {Object} opts
 * @param {BeforeWatchRun} [opts.beforeRun] - Function to call before
 * `mocha.run()`
 * @param {string[]} [opts.watchFiles] - List of paths and patterns to watch. If
 *   not provided all files with an extension included in
 *   `fileCollectionParams.extension` are watched. See first argument of
 *   `chokidar.watch`.
 * @param {string[]} [opts.watchIgnore] - List of paths and patterns to exclude
 *   from watching. See `ignored` option of `chokidar`.
 * @param {FileCollectionOptions} opts.fileCollectParams - List of extensions to watch if `opts.watchFiles` is not given.
 * @returns {FSWatcher}
 * @ignore
 * @private
 */
var createWatcher = function createWatcher(mocha, _ref5) {
  var watchFiles = _ref5.watchFiles,
      watchIgnore = _ref5.watchIgnore,
      beforeRun = _ref5.beforeRun,
      fileCollectParams = _ref5.fileCollectParams;

  if (!watchFiles) {
    watchFiles = fileCollectParams.extension.map(function (ext) {
      return '**/*.' + ext;
    });
  }

  debug('ignoring files matching: %s', watchIgnore);
  var globalFixtureContext = void 0;

  // we handle global fixtures manually
  mocha.enableGlobalSetup(false).enableGlobalTeardown(false);

  var watcher = chokidar.watch(watchFiles, {
    ignored: watchIgnore,
    ignoreInitial: true
  });

  var rerunner = createRerunner(mocha, watcher, {
    beforeRun: beforeRun
  });

  watcher.on('ready', _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (globalFixtureContext) {
              _context.next = 5;
              break;
            }

            debug('triggering global setup');
            _context.next = 4;
            return mocha.runGlobalSetup();

          case 4:
            globalFixtureContext = _context.sent;

          case 5:
            rerunner.run();

          case 6:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this);
  })));

  watcher.on('all', function () {
    rerunner.scheduleRun();
  });

  hideCursor();
  process.on('exit', function () {
    showCursor();
  });

  // this is for testing.
  // win32 cannot gracefully shutdown via a signal from a parent
  // process; a `SIGINT` from a parent will cause the process
  // to immediately exit.  during normal course of operation, a user
  // will type Ctrl-C and the listener will be invoked, but this
  // is not possible in automated testing.
  // there may be another way to solve this, but it too will be a hack.
  // for our watch tests on win32 we must _fork_ mocha with an IPC channel
  if (process.connected) {
    process.on('message', function (msg) {
      if (msg === 'SIGINT') {
        process.emit('SIGINT');
      }
    });
  }

  var exiting = false;
  process.on('SIGINT', _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            showCursor();
            console.error(logSymbols.warning + ' [mocha] cleaning up, please wait...');

            if (exiting) {
              _context2.next = 15;
              break;
            }

            exiting = true;

            if (!mocha.hasGlobalTeardownFixtures()) {
              _context2.next = 14;
              break;
            }

            debug('running global teardown');
            _context2.prev = 6;
            _context2.next = 9;
            return mocha.runGlobalTeardown(globalFixtureContext);

          case 9:
            _context2.next = 14;
            break;

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2['catch'](6);

            console.error(_context2.t0);

          case 14:
            process.exit(130);

          case 15:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, _this, [[6, 11]]);
  })));

  // Keyboard shortcut for restarting when "rs\n" is typed (ala Nodemon)
  process.stdin.resume();
  process.stdin.setEncoding('utf8');
  process.stdin.on('data', function (data) {
    var str = data.toString().trim().toLowerCase();
    if (str === 'rs') rerunner.scheduleRun();
  });

  return watcher;
};

/**
 * Create an object that allows you to rerun tests on the mocha instance.
 *
 * @param {Mocha} mocha - Mocha instance
 * @param {FSWatcher} watcher - chokidar `FSWatcher` instance
 * @param {Object} [opts] - Options!
 * @param {BeforeWatchRun} [opts.beforeRun] - Function to call before `mocha.run()`
 * @returns {Rerunner}
 * @ignore
 * @private
 */
var createRerunner = function createRerunner(mocha, watcher) {
  var _ref8 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      beforeRun = _ref8.beforeRun;

  // Set to a `Runner` when mocha is running. Set to `null` when mocha is not
  // running.
  var runner = null;

  // true if a file has changed during a test run
  var rerunScheduled = false;

  var run = function run() {
    try {
      mocha = beforeRun ? beforeRun({ mocha: mocha, watcher: watcher }) || mocha : mocha;
      runner = mocha.run(function () {
        debug('finished watch run');
        runner = null;
        blastCache(watcher);
        if (rerunScheduled) {
          rerun();
        } else {
          console.error(logSymbols.info + ' [mocha] waiting for changes...');
        }
      });
    } catch (e) {
      console.error(e.stack);
    }
  };

  var scheduleRun = function scheduleRun() {
    if (rerunScheduled) {
      return;
    }

    rerunScheduled = true;
    if (runner) {
      runner.abort();
    } else {
      rerun();
    }
  };

  var rerun = function rerun() {
    rerunScheduled = false;
    eraseLine();
    run();
  };

  return {
    scheduleRun: scheduleRun,
    run: run
  };
};

/**
 * Return the list of absolute paths watched by a chokidar watcher.
 *
 * @param watcher - Instance of a chokidar watcher
 * @return {string[]} - List of absolute paths
 * @ignore
 * @private
 */
var getWatchedFiles = function getWatchedFiles(watcher) {
  var watchedDirs = watcher.getWatched();
  return Object.keys(watchedDirs).reduce(function (acc, dir) {
    return [].concat(_toConsumableArray(acc), _toConsumableArray(watchedDirs[dir].map(function (file) {
      return path.join(dir, file);
    })));
  }, []);
};

/**
 * Hide the cursor.
 * @ignore
 * @private
 */
var hideCursor = function hideCursor() {
  process.stdout.write('\x1B[?25l');
};

/**
 * Show the cursor.
 * @ignore
 * @private
 */
var showCursor = function showCursor() {
  process.stdout.write('\x1B[?25h');
};

/**
 * Erases the line on stdout
 * @private
 */
var eraseLine = function eraseLine() {
  process.stdout.write('\x1B[2K');
};

/**
 * Blast all of the watched files out of `require.cache`
 * @param {FSWatcher} watcher - chokidar FSWatcher
 * @ignore
 * @private
 */
var blastCache = function blastCache(watcher) {
  var files = getWatchedFiles(watcher);
  files.forEach(function (file) {
    delete require.cache[file];
  });
  debug('deleted %d file(s) from the require cache', files.length);
};

/**
 * Callback to be run before `mocha.run()` is called.
 * Optionally, it can return a new `Mocha` instance.
 * @callback BeforeWatchRun
 * @private
 * @param {{mocha: Mocha, watcher: FSWatcher}} options
 * @returns {Mocha}
 */

/**
 * Object containing run control methods
 * @typedef {Object} Rerunner
 * @private
 * @property {Function} run - Calls `mocha.run()`
 * @property {Function} scheduleRun - Schedules another call to `run`
 */