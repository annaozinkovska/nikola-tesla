'use strict';

/**
 * Definition for Mocha's default ("run tests") command
 *
 * @module
 * @private
 */

import _regeneratorRuntime from 'babel-runtime/regenerator';

var _this = this;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var symbols = require('log-symbols');
var ansi = require('ansi-colors');
var Mocha = require('../mocha');

var _require = require('../errors'),
    createUnsupportedError = _require.createUnsupportedError,
    createInvalidArgumentValueError = _require.createInvalidArgumentValueError,
    createMissingArgumentError = _require.createMissingArgumentError;

var _require2 = require('./run-helpers'),
    list = _require2.list,
    handleRequires = _require2.handleRequires,
    validateLegacyPlugin = _require2.validateLegacyPlugin,
    runMocha = _require2.runMocha;

var _require3 = require('./one-and-dones'),
    ONE_AND_DONES = _require3.ONE_AND_DONES,
    ONE_AND_DONE_ARGS = _require3.ONE_AND_DONE_ARGS;

var debug = require('debug')('mocha:cli:run');
var defaults = require('../mocharc');

var _require4 = require('./run-option-metadata'),
    types = _require4.types,
    aliases = _require4.aliases;

/**
 * Logical option groups
 * @constant
 */


var GROUPS = {
  FILES: 'File Handling',
  FILTERS: 'Test Filters',
  NODEJS: 'Node.js & V8',
  OUTPUT: 'Reporting & Output',
  RULES: 'Rules & Behavior',
  CONFIG: 'Configuration'
};

exports.command = ['$0 [spec..]', 'inspect'];

exports.describe = 'Run tests with Mocha';

exports.builder = function (yargs) {
  return yargs.options({
    'allow-uncaught': {
      description: 'Allow uncaught errors to propagate',
      group: GROUPS.RULES
    },
    'async-only': {
      description: 'Require all tests to use a callback (async) or return a Promise',
      group: GROUPS.RULES
    },
    bail: {
      description: 'Abort ("bail") after first test failure',
      group: GROUPS.RULES
    },
    'check-leaks': {
      description: 'Check for global variable leaks',
      group: GROUPS.RULES
    },
    color: {
      description: 'Force-enable color output',
      group: GROUPS.OUTPUT
    },
    config: {
      config: true,
      defaultDescription: '(nearest rc file)',
      description: 'Path to config file',
      group: GROUPS.CONFIG
    },
    delay: {
      description: 'Delay initial execution of root suite',
      group: GROUPS.RULES
    },
    diff: {
      default: true,
      description: 'Show diff on failure',
      group: GROUPS.OUTPUT
    },
    'dry-run': {
      description: 'Report tests without executing them',
      group: GROUPS.RULES
    },
    exit: {
      description: 'Force Mocha to quit after tests complete',
      group: GROUPS.RULES
    },
    extension: {
      default: defaults.extension,
      description: 'File extension(s) to load',
      group: GROUPS.FILES,
      requiresArg: true,
      coerce: list
    },
    'fail-zero': {
      description: 'Fail test run if no test(s) encountered',
      group: GROUPS.RULES
    },
    fgrep: {
      conflicts: 'grep',
      description: 'Only run tests containing this string',
      group: GROUPS.FILTERS,
      requiresArg: true
    },
    file: {
      defaultDescription: '(none)',
      description: 'Specify file(s) to be loaded prior to root suite execution',
      group: GROUPS.FILES,
      normalize: true,
      requiresArg: true
    },
    'forbid-only': {
      description: 'Fail if exclusive test(s) encountered',
      group: GROUPS.RULES
    },
    'forbid-pending': {
      description: 'Fail if pending test(s) encountered',
      group: GROUPS.RULES
    },
    'full-trace': {
      description: 'Display full stack traces',
      group: GROUPS.OUTPUT
    },
    global: {
      coerce: list,
      description: 'List of allowed global variables',
      group: GROUPS.RULES,
      requiresArg: true
    },
    grep: {
      coerce: function coerce(value) {
        return !value ? null : value;
      },
      conflicts: 'fgrep',
      description: 'Only run tests matching this string or regexp',
      group: GROUPS.FILTERS,
      requiresArg: true
    },
    ignore: {
      defaultDescription: '(none)',
      description: 'Ignore file(s) or glob pattern(s)',
      group: GROUPS.FILES,
      requiresArg: true
    },
    'inline-diffs': {
      description: 'Display actual/expected differences inline within each string',
      group: GROUPS.OUTPUT
    },
    invert: {
      description: 'Inverts --grep and --fgrep matches',
      group: GROUPS.FILTERS
    },
    jobs: {
      description: 'Number of concurrent jobs for --parallel; use 1 to run in serial',
      defaultDescription: '(number of CPU cores - 1)',
      requiresArg: true,
      group: GROUPS.RULES
    },
    'list-interfaces': {
      conflicts: Array.from(ONE_AND_DONE_ARGS),
      description: 'List built-in user interfaces & exit'
    },
    'list-reporters': {
      conflicts: Array.from(ONE_AND_DONE_ARGS),
      description: 'List built-in reporters & exit'
    },
    'no-colors': {
      description: 'Force-disable color output',
      group: GROUPS.OUTPUT,
      hidden: true
    },
    'node-option': {
      description: 'Node or V8 option (no leading "--")',
      group: GROUPS.CONFIG
    },
    package: {
      description: 'Path to package.json for config',
      group: GROUPS.CONFIG,
      normalize: true,
      requiresArg: true
    },
    parallel: {
      description: 'Run tests in parallel',
      group: GROUPS.RULES
    },
    recursive: {
      description: 'Look for tests in subdirectories',
      group: GROUPS.FILES
    },
    reporter: {
      default: defaults.reporter,
      description: 'Specify reporter to use',
      group: GROUPS.OUTPUT,
      requiresArg: true
    },
    'reporter-option': {
      coerce: function coerce(opts) {
        return list(opts).reduce(function (acc, opt) {
          var pair = opt.split('=');

          if (pair.length > 2 || !pair.length) {
            throw createInvalidArgumentValueError('invalid reporter option \'' + opt + '\'', '--reporter-option', opt, 'expected "key=value" format');
          }

          acc[pair[0]] = pair.length === 2 ? pair[1] : true;
          return acc;
        }, {});
      },
      description: 'Reporter-specific options (<k=v,[k1=v1,..]>)',
      group: GROUPS.OUTPUT,
      requiresArg: true
    },
    require: {
      defaultDescription: '(none)',
      description: 'Require module',
      group: GROUPS.FILES,
      requiresArg: true
    },
    retries: {
      description: 'Retry failed tests this many times',
      group: GROUPS.RULES
    },
    slow: {
      default: defaults.slow,
      description: 'Specify "slow" test threshold (in milliseconds)',
      group: GROUPS.RULES
    },
    sort: {
      description: 'Sort test files',
      group: GROUPS.FILES
    },
    timeout: {
      default: defaults.timeout,
      description: 'Specify test timeout threshold (in milliseconds)',
      group: GROUPS.RULES
    },
    ui: {
      default: defaults.ui,
      description: 'Specify user interface',
      group: GROUPS.RULES,
      requiresArg: true
    },
    watch: {
      description: 'Watch files in the current working directory for changes',
      group: GROUPS.FILES
    },
    'watch-files': {
      description: 'List of paths or globs to watch',
      group: GROUPS.FILES,
      requiresArg: true,
      coerce: list
    },
    'watch-ignore': {
      description: 'List of paths or globs to exclude from watching',
      group: GROUPS.FILES,
      requiresArg: true,
      coerce: list,
      default: defaults['watch-ignore']
    }
  }).positional('spec', {
    default: ['test'],
    description: 'One or more files, directories, or globs to test',
    type: 'array'
  }).check(function (argv) {
    // "one-and-dones"; let yargs handle help and version
    Object.keys(ONE_AND_DONES).forEach(function (opt) {
      if (argv[opt]) {
        ONE_AND_DONES[opt].call(null, yargs);
        process.exit();
      }
    });

    // yargs.implies() isn't flexible enough to handle this
    if (argv.invert && !('fgrep' in argv || 'grep' in argv)) {
      throw createMissingArgumentError('"--invert" requires one of "--fgrep <str>" or "--grep <regexp>"', '--fgrep|--grep', 'string|regexp');
    }

    if (argv.parallel) {
      // yargs.conflicts() can't deal with `--file foo.js --no-parallel`, either
      if (argv.file) {
        throw createUnsupportedError('--parallel runs test files in a non-deterministic order, and is mutually exclusive with --file');
      }

      // or this
      if (argv.sort) {
        throw createUnsupportedError('--parallel runs test files in a non-deterministic order, and is mutually exclusive with --sort');
      }

      if (argv.reporter === 'progress') {
        throw createUnsupportedError('--reporter=progress is mutually exclusive with --parallel');
      }

      if (argv.reporter === 'markdown') {
        throw createUnsupportedError('--reporter=markdown is mutually exclusive with --parallel');
      }

      if (argv.reporter === 'json-stream') {
        throw createUnsupportedError('--reporter=json-stream is mutually exclusive with --parallel');
      }
    }

    if (argv.compilers) {
      throw createUnsupportedError('--compilers is DEPRECATED and no longer supported.\n          See https://github.com/mochajs/mocha/wiki/compilers-deprecation for migration information.');
    }

    if (argv.opts) {
      throw createUnsupportedError('--opts: configuring Mocha via \'mocha.opts\' is DEPRECATED and no longer supported.\n          Please use a configuration file instead.');
    }

    return true;
  }).middleware(function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(argv, yargs) {
      var plugins;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return handleRequires(argv.require);

            case 3:
              plugins = _context.sent;

              validateLegacyPlugin(argv, 'reporter', Mocha.reporters);
              validateLegacyPlugin(argv, 'ui', Mocha.interfaces);
              Object.assign(argv, plugins);
              _context.next = 13;
              break;

            case 9:
              _context.prev = 9;
              _context.t0 = _context['catch'](0);

              // this could be a bad --require, bad reporter, ui, etc.
              console.error('\n' + symbols.error + ' ' + ansi.red('ERROR:'), _context.t0);
              yargs.exit(1);

            case 13:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this, [[0, 9]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }()).array(types.array).boolean(types.boolean).string(types.string).number(types.number).alias(aliases);
};

exports.handler = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(argv) {
    var mocha;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            debug('post-yargs config', argv);
            mocha = new Mocha(argv);
            _context2.prev = 2;
            _context2.next = 5;
            return runMocha(mocha, argv);

          case 5:
            _context2.next = 11;
            break;

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2['catch'](2);

            console.error('\n' + (_context2.t0.stack || 'Error: ' + (_context2.t0.message || _context2.t0)));
            process.exit(1);

          case 11:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this, [[2, 7]]);
  }));

  return function (_x3) {
    return _ref2.apply(this, arguments);
  };
}();