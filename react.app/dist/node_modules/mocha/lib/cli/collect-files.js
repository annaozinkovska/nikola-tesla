'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var path = require('path');
var ansi = require('ansi-colors');
var debug = require('debug')('mocha:cli:run:helpers');
var minimatch = require('minimatch');

var NO_FILES_MATCH_PATTERN = require('../errors').constants.NO_FILES_MATCH_PATTERN;

var lookupFiles = require('./lookup-files');

var _require = require('../utils'),
    castArray = _require.castArray;

/**
 * Exports a function that collects test files from CLI parameters.
 * @see module:lib/cli/run-helpers
 * @see module:lib/cli/watch-run
 * @module
 * @private
 */

/**
 * Smash together an array of test files in the correct order
 * @param {FileCollectionOptions} [opts] - Options
 * @returns {string[]} List of files to test
 * @private
 */


module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      ignore = _ref.ignore,
      extension = _ref.extension,
      fileArgs = _ref.file,
      recursive = _ref.recursive,
      sort = _ref.sort,
      spec = _ref.spec;

  var unmatched = [];
  var specFiles = spec.reduce(function (specFiles, arg) {
    try {
      var moreSpecFiles = castArray(lookupFiles(arg, extension, recursive)).filter(function (filename) {
        return ignore.every(function (pattern) {
          return !minimatch(filename, pattern);
        });
      }).map(function (filename) {
        return path.resolve(filename);
      });
      return [].concat(_toConsumableArray(specFiles), _toConsumableArray(moreSpecFiles));
    } catch (err) {
      if (err.code === NO_FILES_MATCH_PATTERN) {
        unmatched.push({ message: err.message, pattern: err.pattern });
        return specFiles;
      }

      throw err;
    }
  }, []);

  // ensure we don't sort the stuff from fileArgs; order is important!
  if (sort) {
    specFiles.sort();
  }

  // add files given through --file to be ran first
  var files = [].concat(_toConsumableArray(fileArgs.map(function (filepath) {
    return path.resolve(filepath);
  })), _toConsumableArray(specFiles));
  debug('test files (in order): ', files);

  if (!files.length) {
    // give full message details when only 1 file is missing
    var noneFoundMsg = unmatched.length === 1 ? 'Error: No test files found: ' + JSON.stringify(unmatched[0].pattern) // stringify to print escaped characters raw
    : 'Error: No test files found';
    console.error(ansi.red(noneFoundMsg));
    process.exit(1);
  } else {
    // print messages as a warning
    unmatched.forEach(function (warning) {
      console.warn(ansi.yellow('Warning: ' + warning.message));
    });
  }

  return files;
};

/**
 * An object to configure how Mocha gathers test files
 * @private
 * @typedef {Object} FileCollectionOptions
 * @property {string[]} extension - File extensions to use
 * @property {string[]} spec - Files, dirs, globs to run
 * @property {string[]} ignore - Files, dirs, globs to ignore
 * @property {string[]} file - List of additional files to include
 * @property {boolean} recursive - Find files recursively
 * @property {boolean} sort - Sort test files
 */