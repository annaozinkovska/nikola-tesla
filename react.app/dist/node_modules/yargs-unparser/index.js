'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var flatten = require('flat');
var camelcase = require('camelcase');
var decamelize = require('decamelize');
var isPlainObj = require('is-plain-obj');

function isAlias(key, alias) {
    // TODO Switch to Object.values one Node.js 6 is dropped
    return Object.keys(alias).some(function (id) {
        return [].concat(alias[id]).indexOf(key) !== -1;
    });
}

function hasDefaultValue(key, value, defaults) {
    return value === defaults[key];
}

function isCamelCased(key, argv) {
    return (/[A-Z]/.test(key) && camelcase(key) === key && // Is it camel case?
        argv[decamelize(key, '-')] != null
    ); // Is the standard version defined?
}

function keyToFlag(key) {
    return key.length === 1 ? '-' + key : '--' + key;
}

function parseCommand(cmd) {
    var extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
    var splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
    var bregex = /\.*[\][<>]/g;
    var firstCommand = splitCommand.shift();

    if (!firstCommand) {
        throw new Error('No command found in: ' + cmd);
    }
    var parsedCommand = {
        cmd: firstCommand.replace(bregex, ''),
        demanded: [],
        optional: []
    };

    splitCommand.forEach(function (cmd, i) {
        var variadic = false;

        cmd = cmd.replace(/\s/g, '');
        if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1) {
            variadic = true;
        }
        if (/^\[/.test(cmd)) {
            parsedCommand.optional.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic: variadic
            });
        } else {
            parsedCommand.demanded.push({
                cmd: cmd.replace(bregex, '').split('|'),
                variadic: variadic
            });
        }
    });

    return parsedCommand;
}

function unparseOption(key, value, unparsed) {
    if (typeof value === 'string') {
        unparsed.push(keyToFlag(key), value);
    } else if (value === true) {
        unparsed.push(keyToFlag(key));
    } else if (value === false) {
        unparsed.push('--no-' + key);
    } else if (Array.isArray(value)) {
        value.forEach(function (item) {
            return unparseOption(key, item, unparsed);
        });
    } else if (isPlainObj(value)) {
        var flattened = flatten(value, { safe: true });

        for (var flattenedKey in flattened) {
            if (!isCamelCased(flattenedKey, flattened)) {
                unparseOption(key + '.' + flattenedKey, flattened[flattenedKey], unparsed);
            }
        }
        // Fallback case (numbers and other types)
    } else if (value != null) {
        unparsed.push(keyToFlag(key), '' + value);
    }
}

function unparsePositional(argv, options, unparsed) {
    var knownPositional = [];

    // Unparse command if set, collecting all known positional arguments
    // e.g.: build <first> <second> <rest...>
    if (options.command) {
        var _options$command$matc = options.command.match(/[^<[]*/),
            cmd = _options$command$matc[0],
            index = _options$command$matc.index;

        var _parseCommand = parseCommand('foo ' + options.command.substr(index + cmd.length)),
            demanded = _parseCommand.demanded,
            optional = _parseCommand.optional;

        // Push command (can be a deep command)


        unparsed.push.apply(unparsed, _toConsumableArray(cmd.trim().split(/\s+/)));

        // Push positional arguments
        [].concat(_toConsumableArray(demanded), _toConsumableArray(optional)).forEach(function (_ref) {
            var cmds = _ref.cmd,
                variadic = _ref.variadic;

            knownPositional.push.apply(knownPositional, _toConsumableArray(cmds));

            var cmd = cmds[0];
            var args = (variadic ? argv[cmd] || [] : [argv[cmd]]).filter(function (arg) {
                return arg != null;
            }).map(function (arg) {
                return '' + arg;
            });

            unparsed.push.apply(unparsed, _toConsumableArray(args));
        });
    }

    // Unparse unkown positional arguments
    argv._ && unparsed.push.apply(unparsed, _toConsumableArray(argv._.slice(knownPositional.length)));

    return knownPositional;
}

function unparseOptions(argv, options, knownPositional, unparsed) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Object.keys(argv)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            var value = argv[key];

            if (
            // Remove positional arguments
            knownPositional.includes(key) ||
            // Remove special _, -- and $0
            ['_', '--', '$0'].includes(key) ||
            // Remove aliases
            isAlias(key, options.alias) ||
            // Remove default values
            hasDefaultValue(key, value, options.default) ||
            // Remove camel-cased
            isCamelCased(key, argv)) {
                continue;
            }

            unparseOption(key, argv[key], unparsed);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}

function unparseEndOfOptions(argv, options, unparsed) {
    // Unparse ending (--) arguments if set
    argv['--'] && unparsed.push.apply(unparsed, ['--'].concat(_toConsumableArray(argv['--'])));
}

// ------------------------------------------------------------

function unparser(argv, options) {
    options = Object.assign({
        alias: {},
        default: {},
        command: null
    }, options);

    var unparsed = [];

    // Unparse known & unknown positional arguments (foo <first> <second> [rest...])
    // All known positional will be returned so that they are not added as flags
    var knownPositional = unparsePositional(argv, options, unparsed);

    // Unparse option arguments (--foo hello --bar hi)
    unparseOptions(argv, options, knownPositional, unparsed);

    // Unparse "end-of-options" arguments (stuff after " -- ")
    unparseEndOfOptions(argv, options, unparsed);

    return unparsed;
}

module.exports = unparser;