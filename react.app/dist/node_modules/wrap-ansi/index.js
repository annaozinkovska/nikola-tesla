'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var stringWidth = require('string-width');
var stripAnsi = require('strip-ansi');
var ansiStyles = require('ansi-styles');

var ESCAPES = new Set(['\x1B', '\x9B']);

var END_CODE = 39;

var ANSI_ESCAPE_BELL = '\x07';
var ANSI_CSI = '[';
var ANSI_OSC = ']';
var ANSI_SGR_TERMINATOR = 'm';
var ANSI_ESCAPE_LINK = ANSI_OSC + '8;;';

var wrapAnsi = function wrapAnsi(code) {
	return '' + ESCAPES.values().next().value + ANSI_CSI + code + ANSI_SGR_TERMINATOR;
};
var wrapAnsiHyperlink = function wrapAnsiHyperlink(uri) {
	return '' + ESCAPES.values().next().value + ANSI_ESCAPE_LINK + uri + ANSI_ESCAPE_BELL;
};

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
var wordLengths = function wordLengths(string) {
	return string.split(' ').map(function (character) {
		return stringWidth(character);
	});
};

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
var wrapWord = function wrapWord(rows, word, columns) {
	var characters = [].concat(_toConsumableArray(word));

	var isInsideEscape = false;
	var isInsideLinkEscape = false;
	var visible = stringWidth(stripAnsi(rows[rows.length - 1]));

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = characters.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _ref = _step.value;

			var _ref2 = _slicedToArray(_ref, 2);

			var index = _ref2[0];
			var character = _ref2[1];

			var characterLength = stringWidth(character);

			if (visible + characterLength <= columns) {
				rows[rows.length - 1] += character;
			} else {
				rows.push(character);
				visible = 0;
			}

			if (ESCAPES.has(character)) {
				isInsideEscape = true;
				isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);
			}

			if (isInsideEscape) {
				if (isInsideLinkEscape) {
					if (character === ANSI_ESCAPE_BELL) {
						isInsideEscape = false;
						isInsideLinkEscape = false;
					}
				} else if (character === ANSI_SGR_TERMINATOR) {
					isInsideEscape = false;
				}

				continue;
			}

			visible += characterLength;

			if (visible === columns && index < characters.length - 1) {
				rows.push('');
				visible = 0;
			}
		}

		// It's possible that the last row we copy over is only
		// ansi escape characters, handle this edge-case
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};

// Trims spaces from a string ignoring invisible sequences
var stringVisibleTrimSpacesRight = function stringVisibleTrimSpacesRight(string) {
	var words = string.split(' ');
	var last = words.length;

	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) {
			break;
		}

		last--;
	}

	if (last === words.length) {
		return string;
	}

	return words.slice(0, last).join(' ') + words.slice(last).join('');
};

// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length
var exec = function exec(string, columns) {
	var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	if (options.trim !== false && string.trim() === '') {
		return '';
	}

	var returnValue = '';
	var escapeCode = void 0;
	var escapeUrl = void 0;

	var lengths = wordLengths(string);
	var rows = [''];

	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = string.split(' ').entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var _ref3 = _step2.value;

			var _ref4 = _slicedToArray(_ref3, 2);

			var index = _ref4[0];
			var word = _ref4[1];

			if (options.trim !== false) {
				rows[rows.length - 1] = rows[rows.length - 1].trimStart();
			}

			var rowLength = stringWidth(rows[rows.length - 1]);

			if (index !== 0) {
				if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
					// If we start with a new word but the current row length equals the length of the columns, add a new row
					rows.push('');
					rowLength = 0;
				}

				if (rowLength > 0 || options.trim === false) {
					rows[rows.length - 1] += ' ';
					rowLength++;
				}
			}

			// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
			if (options.hard && lengths[index] > columns) {
				var remainingColumns = columns - rowLength;
				var breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
				var breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
				if (breaksStartingNextLine < breaksStartingThisLine) {
					rows.push('');
				}

				wrapWord(rows, word, columns);
				continue;
			}

			if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
				if (options.wordWrap === false && rowLength < columns) {
					wrapWord(rows, word, columns);
					continue;
				}

				rows.push('');
			}

			if (rowLength + lengths[index] > columns && options.wordWrap === false) {
				wrapWord(rows, word, columns);
				continue;
			}

			rows[rows.length - 1] += word;
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	if (options.trim !== false) {
		rows = rows.map(stringVisibleTrimSpacesRight);
	}

	var pre = [].concat(_toConsumableArray(rows.join('\n')));

	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = pre.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var _ref5 = _step3.value;

			var _ref6 = _slicedToArray(_ref5, 2);

			var _index = _ref6[0];
			var character = _ref6[1];

			returnValue += character;

			if (ESCAPES.has(character)) {
				var _ref7 = new RegExp('(?:\\' + ANSI_CSI + '(?<code>\\d+)m|\\' + ANSI_ESCAPE_LINK + '(?<uri>.*)' + ANSI_ESCAPE_BELL + ')').exec(pre.slice(_index).join('')) || { groups: {} },
				    groups = _ref7.groups;

				if (groups.code !== undefined) {
					var _code = Number.parseFloat(groups.code);
					escapeCode = _code === END_CODE ? undefined : _code;
				} else if (groups.uri !== undefined) {
					escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
				}
			}

			var code = ansiStyles.codes.get(Number(escapeCode));

			if (pre[_index + 1] === '\n') {
				if (escapeUrl) {
					returnValue += wrapAnsiHyperlink('');
				}

				if (escapeCode && code) {
					returnValue += wrapAnsi(code);
				}
			} else if (character === '\n') {
				if (escapeCode && code) {
					returnValue += wrapAnsi(escapeCode);
				}

				if (escapeUrl) {
					returnValue += wrapAnsiHyperlink(escapeUrl);
				}
			}
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	return returnValue;
};

// For each newline, invoke the method separately
module.exports = function (string, columns, options) {
	return String(string).normalize().replace(/\r\n/g, '\n').split('\n').map(function (line) {
		return exec(line, columns, options);
	}).join('\n');
};