'use strict';

import _regeneratorRuntime from 'babel-runtime/regenerator';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var fs = require('fs');

var _require = require('stream'),
    Readable = _require.Readable;

var sysPath = require('path');

var _require2 = require('util'),
    promisify = _require2.promisify;

var picomatch = require('picomatch');

var readdir = promisify(fs.readdir);
var stat = promisify(fs.stat);
var lstat = promisify(fs.lstat);
var realpath = promisify(fs.realpath);

/**
 * @typedef {Object} EntryInfo
 * @property {String} path
 * @property {String} fullPath
 * @property {fs.Stats=} stats
 * @property {fs.Dirent=} dirent
 * @property {String} basename
 */

var BANG = '!';
var RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
var NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);
var FILE_TYPE = 'files';
var DIR_TYPE = 'directories';
var FILE_DIR_TYPE = 'files_directories';
var EVERYTHING_TYPE = 'all';
var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

var isNormalFlowError = function isNormalFlowError(error) {
  return NORMAL_FLOW_ERRORS.has(error.code);
};

var _process$versions$nod = process.versions.node.split('.').slice(0, 2).map(function (n) {
  return Number.parseInt(n, 10);
}),
    _process$versions$nod2 = _slicedToArray(_process$versions$nod, 2),
    maj = _process$versions$nod2[0],
    min = _process$versions$nod2[1];

var wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);

var normalizeFilter = function normalizeFilter(filter) {
  if (filter === undefined) return;
  if (typeof filter === 'function') return filter;

  if (typeof filter === 'string') {
    var glob = picomatch(filter.trim());
    return function (entry) {
      return glob(entry.basename);
    };
  }

  if (Array.isArray(filter)) {
    var positive = [];
    var negative = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = filter[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        var trimmed = item.trim();
        if (trimmed.charAt(0) === BANG) {
          negative.push(picomatch(trimmed.slice(1)));
        } else {
          positive.push(picomatch(trimmed));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (negative.length > 0) {
      if (positive.length > 0) {
        return function (entry) {
          return positive.some(function (f) {
            return f(entry.basename);
          }) && !negative.some(function (f) {
            return f(entry.basename);
          });
        };
      }
      return function (entry) {
        return !negative.some(function (f) {
          return f(entry.basename);
        });
      };
    }
    return function (entry) {
      return positive.some(function (f) {
        return f(entry.basename);
      });
    };
  }
};

var ReaddirpStream = function (_Readable) {
  _inherits(ReaddirpStream, _Readable);

  _createClass(ReaddirpStream, null, [{
    key: 'defaultOptions',
    get: function get() {
      return {
        root: '.',
        /* eslint-disable no-unused-vars */
        fileFilter: function fileFilter(path) {
          return true;
        },
        directoryFilter: function directoryFilter(path) {
          return true;
        },
        /* eslint-enable no-unused-vars */
        type: FILE_TYPE,
        lstat: false,
        depth: 2147483648,
        alwaysStat: false
      };
    }
  }]);

  function ReaddirpStream() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ReaddirpStream);

    var _this = _possibleConstructorReturn(this, (ReaddirpStream.__proto__ || Object.getPrototypeOf(ReaddirpStream)).call(this, {
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options.highWaterMark || 4096
    }));

    var opts = Object.assign({}, ReaddirpStream.defaultOptions, options);
    var root = opts.root,
        type = opts.type;


    _this._fileFilter = normalizeFilter(opts.fileFilter);
    _this._directoryFilter = normalizeFilter(opts.directoryFilter);

    var statMethod = opts.lstat ? lstat : stat;
    // Use bigint stats if it's windows and stat() supports options (node 10+).
    if (wantBigintFsStats) {
      _this._stat = function (path) {
        return statMethod(path, { bigint: true });
      };
    } else {
      _this._stat = statMethod;
    }

    _this._maxDepth = opts.depth;
    _this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    _this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    _this._wantsEverything = type === EVERYTHING_TYPE;
    _this._root = sysPath.resolve(root);
    _this._isDirent = 'Dirent' in fs && !opts.alwaysStat;
    _this._statsProp = _this._isDirent ? 'dirent' : 'stats';
    _this._rdOptions = { encoding: 'utf8', withFileTypes: _this._isDirent };

    // Launch stream with one parent, the root dir.
    _this.parents = [_this._exploreDir(root, 1)];
    _this.reading = false;
    _this.parent = undefined;
    return _this;
  }

  _createClass(ReaddirpStream, [{
    key: '_read',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(batch) {
        var _this2 = this;

        var _loop, _ret;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.reading) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return');

              case 2:
                this.reading = true;

                _context2.prev = 3;
                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
                  var _ref2, path, depth, _ref2$files, files, slice, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, entry, entryType, parent;

                  return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _ref2 = _this2.parent || {}, path = _ref2.path, depth = _ref2.depth, _ref2$files = _ref2.files, files = _ref2$files === undefined ? [] : _ref2$files;

                          if (!(files.length > 0)) {
                            _context.next = 38;
                            break;
                          }

                          slice = files.splice(0, batch).map(function (dirent) {
                            return _this2._formatEntry(dirent, path);
                          });
                          _iteratorNormalCompletion2 = true;
                          _didIteratorError2 = false;
                          _iteratorError2 = undefined;
                          _context.prev = 6;
                          _context.next = 9;
                          return Promise.all(slice);

                        case 9:
                          _context.t0 = Symbol.iterator;
                          _iterator2 = _context.sent[_context.t0]();

                        case 11:
                          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                            _context.next = 22;
                            break;
                          }

                          entry = _step2.value;

                          if (!_this2.destroyed) {
                            _context.next = 15;
                            break;
                          }

                          return _context.abrupt('return', {
                            v: void 0
                          });

                        case 15:
                          _context.next = 17;
                          return _this2._getEntryType(entry);

                        case 17:
                          entryType = _context.sent;

                          if (entryType === 'directory' && _this2._directoryFilter(entry)) {
                            if (depth <= _this2._maxDepth) {
                              _this2.parents.push(_this2._exploreDir(entry.fullPath, depth + 1));
                            }

                            if (_this2._wantsDir) {
                              _this2.push(entry);
                              batch--;
                            }
                          } else if ((entryType === 'file' || _this2._includeAsFile(entry)) && _this2._fileFilter(entry)) {
                            if (_this2._wantsFile) {
                              _this2.push(entry);
                              batch--;
                            }
                          }

                        case 19:
                          _iteratorNormalCompletion2 = true;
                          _context.next = 11;
                          break;

                        case 22:
                          _context.next = 28;
                          break;

                        case 24:
                          _context.prev = 24;
                          _context.t1 = _context['catch'](6);
                          _didIteratorError2 = true;
                          _iteratorError2 = _context.t1;

                        case 28:
                          _context.prev = 28;
                          _context.prev = 29;

                          if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                          }

                        case 31:
                          _context.prev = 31;

                          if (!_didIteratorError2) {
                            _context.next = 34;
                            break;
                          }

                          throw _iteratorError2;

                        case 34:
                          return _context.finish(31);

                        case 35:
                          return _context.finish(28);

                        case 36:
                          _context.next = 47;
                          break;

                        case 38:
                          parent = _this2.parents.pop();

                          if (parent) {
                            _context.next = 42;
                            break;
                          }

                          _this2.push(null);
                          return _context.abrupt('return', 'break');

                        case 42:
                          _context.next = 44;
                          return parent;

                        case 44:
                          _this2.parent = _context.sent;

                          if (!_this2.destroyed) {
                            _context.next = 47;
                            break;
                          }

                          return _context.abrupt('return', {
                            v: void 0
                          });

                        case 47:
                        case 'end':
                          return _context.stop();
                      }
                    }
                  }, _callee, _this2, [[6, 24, 28, 36], [29,, 31, 35]]);
                });

              case 5:
                if (!(!this.destroyed && batch > 0)) {
                  _context2.next = 16;
                  break;
                }

                return _context2.delegateYield(_loop(), 't0', 7);

              case 7:
                _ret = _context2.t0;
                _context2.t1 = _ret;
                _context2.next = _context2.t1 === 'break' ? 11 : 12;
                break;

              case 11:
                return _context2.abrupt('break', 16);

              case 12:
                if (!((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object")) {
                  _context2.next = 14;
                  break;
                }

                return _context2.abrupt('return', _ret.v);

              case 14:
                _context2.next = 5;
                break;

              case 16:
                _context2.next = 21;
                break;

              case 18:
                _context2.prev = 18;
                _context2.t2 = _context2['catch'](3);

                this.destroy(_context2.t2);

              case 21:
                _context2.prev = 21;

                this.reading = false;
                return _context2.finish(21);

              case 24:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this, [[3, 18, 21, 24]]);
      }));

      function _read(_x2) {
        return _ref.apply(this, arguments);
      }

      return _read;
    }()
  }, {
    key: '_exploreDir',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path, depth) {
        var files;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                files = void 0;
                _context3.prev = 1;
                _context3.next = 4;
                return readdir(path, this._rdOptions);

              case 4:
                files = _context3.sent;
                _context3.next = 10;
                break;

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3['catch'](1);

                this._onError(_context3.t0);

              case 10:
                return _context3.abrupt('return', { files: files, depth: depth, path: path });

              case 11:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 7]]);
      }));

      function _exploreDir(_x3, _x4) {
        return _ref3.apply(this, arguments);
      }

      return _exploreDir;
    }()
  }, {
    key: '_formatEntry',
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(dirent, path) {
        var entry, basename, fullPath;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                entry = void 0;
                _context4.prev = 1;
                basename = this._isDirent ? dirent.name : dirent;
                fullPath = sysPath.resolve(sysPath.join(path, basename));

                entry = { path: sysPath.relative(this._root, fullPath), fullPath: fullPath, basename: basename };

                if (!this._isDirent) {
                  _context4.next = 9;
                  break;
                }

                _context4.t0 = dirent;
                _context4.next = 12;
                break;

              case 9:
                _context4.next = 11;
                return this._stat(fullPath);

              case 11:
                _context4.t0 = _context4.sent;

              case 12:
                entry[this._statsProp] = _context4.t0;
                _context4.next = 18;
                break;

              case 15:
                _context4.prev = 15;
                _context4.t1 = _context4['catch'](1);

                this._onError(_context4.t1);

              case 18:
                return _context4.abrupt('return', entry);

              case 19:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 15]]);
      }));

      function _formatEntry(_x5, _x6) {
        return _ref4.apply(this, arguments);
      }

      return _formatEntry;
    }()
  }, {
    key: '_onError',
    value: function _onError(err) {
      if (isNormalFlowError(err) && !this.destroyed) {
        this.emit('warn', err);
      } else {
        this.destroy(err);
      }
    }
  }, {
    key: '_getEntryType',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(entry) {
        var stats, full, entryRealPath, entryRealPathStats, len, recursiveError;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // entry may be undefined, because a warning or an error were emitted
                // and the statsProp is undefined
                stats = entry && entry[this._statsProp];

                if (stats) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt('return');

              case 3:
                if (!stats.isFile()) {
                  _context5.next = 5;
                  break;
                }

                return _context5.abrupt('return', 'file');

              case 5:
                if (!stats.isDirectory()) {
                  _context5.next = 7;
                  break;
                }

                return _context5.abrupt('return', 'directory');

              case 7:
                if (!(stats && stats.isSymbolicLink())) {
                  _context5.next = 30;
                  break;
                }

                full = entry.fullPath;
                _context5.prev = 9;
                _context5.next = 12;
                return realpath(full);

              case 12:
                entryRealPath = _context5.sent;
                _context5.next = 15;
                return lstat(entryRealPath);

              case 15:
                entryRealPathStats = _context5.sent;

                if (!entryRealPathStats.isFile()) {
                  _context5.next = 18;
                  break;
                }

                return _context5.abrupt('return', 'file');

              case 18:
                if (!entryRealPathStats.isDirectory()) {
                  _context5.next = 25;
                  break;
                }

                len = entryRealPath.length;

                if (!(full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep)) {
                  _context5.next = 24;
                  break;
                }

                recursiveError = new Error('Circular symlink detected: "' + full + '" points to "' + entryRealPath + '"');

                recursiveError.code = RECURSIVE_ERROR_CODE;
                return _context5.abrupt('return', this._onError(recursiveError));

              case 24:
                return _context5.abrupt('return', 'directory');

              case 25:
                _context5.next = 30;
                break;

              case 27:
                _context5.prev = 27;
                _context5.t0 = _context5['catch'](9);

                this._onError(_context5.t0);

              case 30:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this, [[9, 27]]);
      }));

      function _getEntryType(_x7) {
        return _ref5.apply(this, arguments);
      }

      return _getEntryType;
    }()
  }, {
    key: '_includeAsFile',
    value: function _includeAsFile(entry) {
      var stats = entry && entry[this._statsProp];

      return stats && this._wantsEverything && !stats.isDirectory();
    }
  }]);

  return ReaddirpStream;
}(Readable);

/**
 * @typedef {Object} ReaddirpArguments
 * @property {Function=} fileFilter
 * @property {Function=} directoryFilter
 * @property {String=} type
 * @property {Number=} depth
 * @property {String=} root
 * @property {Boolean=} lstat
 * @property {Boolean=} bigint
 */

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param {String} root Root directory
 * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
 */


var readdirp = function readdirp(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var type = options.entryType || options.type;
  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility
  if (type) options.type = type;
  if (!root) {
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
  } else if (typeof root !== 'string') {
    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error('readdirp: Invalid type passed. Use one of ' + ALL_TYPES.join(', '));
  }

  options.root = root;
  return new ReaddirpStream(options);
};

var readdirpPromise = function readdirpPromise(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return new Promise(function (resolve, reject) {
    var files = [];
    readdirp(root, options).on('data', function (entry) {
      return files.push(entry);
    }).on('end', function () {
      return resolve(files);
    }).on('error', function (error) {
      return reject(error);
    });
  });
};

readdirp.promise = readdirpPromise;
readdirp.ReaddirpStream = ReaddirpStream;
readdirp.default = readdirp;

module.exports = readdirp;