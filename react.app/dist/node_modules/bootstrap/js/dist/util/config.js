var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*!
  * Bootstrap config.js v5.2.3 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./index'), require('../dom/manipulator')) : typeof define === 'function' && define.amd ? define(['./index', '../dom/manipulator'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Config = factory(global.Index, global.Manipulator));
})(this, function (index, Manipulator) {
  'use strict';

  var _interopDefaultLegacy = function _interopDefaultLegacy(e) {
    return e && (typeof e === 'undefined' ? 'undefined' : _typeof(e)) === 'object' && 'default' in e ? e : { default: e };
  };

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.2.3): util/config.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */
  /**
   * Class definition
   */

  var Config = function () {
    function Config() {
      _classCallCheck(this, Config);
    }

    _createClass(Config, [{
      key: '_getConfig',
      value: function _getConfig(config) {
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);

        this._typeCheckConfig(config);

        return config;
      }
    }, {
      key: '_configAfterMerge',
      value: function _configAfterMerge(config) {
        return config;
      }
    }, {
      key: '_mergeConfigObj',
      value: function _mergeConfigObj(config, element) {
        var jsonConfig = index.isElement(element) ? Manipulator__default.default.getDataAttribute(element, 'config') : {}; // try to parse

        return Object.assign({}, this.constructor.Default, (typeof jsonConfig === 'undefined' ? 'undefined' : _typeof(jsonConfig)) === 'object' ? jsonConfig : {}, index.isElement(element) ? Manipulator__default.default.getDataAttributes(element) : {}, (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' ? config : {});
      }
    }, {
      key: '_typeCheckConfig',
      value: function _typeCheckConfig(config) {
        var configTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.DefaultType;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = Object.keys(configTypes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var property = _step.value;

            var expectedTypes = configTypes[property];
            var value = config[property];
            var valueType = index.isElement(value) ? 'element' : index.toType(value);

            if (!new RegExp(expectedTypes).test(valueType)) {
              throw new TypeError(this.constructor.NAME.toUpperCase() + ': Option "' + property + '" provided type "' + valueType + '" but expected type "' + expectedTypes + '".');
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }], [{
      key: 'Default',

      // Getters
      get: function get() {
        return {};
      }
    }, {
      key: 'DefaultType',
      get: function get() {
        return {};
      }
    }, {
      key: 'NAME',
      get: function get() {
        throw new Error('You have to implement the static method "NAME", for each component!');
      }
    }]);

    return Config;
  }();

  return Config;
});
//# sourceMappingURL=config.js.map