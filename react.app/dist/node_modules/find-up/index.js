'use strict';

import _regeneratorRuntime from 'babel-runtime/regenerator';

var _this = this;

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var path = require('path');
var locatePath = require('locate-path');
var pathExists = require('path-exists');

var stop = Symbol('findUp.stop');

module.exports = function () {
	var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var directory, _path$parse, root, paths, runMatcher, foundPath;

		return _regeneratorRuntime.wrap(function _callee2$(_context2) {
			while (1) {
				switch (_context2.prev = _context2.next) {
					case 0:
						directory = path.resolve(options.cwd || '');
						_path$parse = path.parse(directory), root = _path$parse.root;
						paths = [].concat(name);

						runMatcher = function () {
							var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(locateOptions) {
								var foundPath;
								return _regeneratorRuntime.wrap(function _callee$(_context) {
									while (1) {
										switch (_context.prev = _context.next) {
											case 0:
												if (!(typeof name !== 'function')) {
													_context.next = 2;
													break;
												}

												return _context.abrupt('return', locatePath(paths, locateOptions));

											case 2:
												_context.next = 4;
												return name(locateOptions.cwd);

											case 4:
												foundPath = _context.sent;

												if (!(typeof foundPath === 'string')) {
													_context.next = 7;
													break;
												}

												return _context.abrupt('return', locatePath([foundPath], locateOptions));

											case 7:
												return _context.abrupt('return', foundPath);

											case 8:
											case 'end':
												return _context.stop();
										}
									}
								}, _callee, _this);
							}));

							return function runMatcher(_x3) {
								return _ref2.apply(this, arguments);
							};
						}();

						// eslint-disable-next-line no-constant-condition


					case 4:
						if (!true) {
							_context2.next = 17;
							break;
						}

						_context2.next = 7;
						return runMatcher(Object.assign({}, options, { cwd: directory }));

					case 7:
						foundPath = _context2.sent;

						if (!(foundPath === stop)) {
							_context2.next = 10;
							break;
						}

						return _context2.abrupt('return');

					case 10:
						if (!foundPath) {
							_context2.next = 12;
							break;
						}

						return _context2.abrupt('return', path.resolve(directory, foundPath));

					case 12:
						if (!(directory === root)) {
							_context2.next = 14;
							break;
						}

						return _context2.abrupt('return');

					case 14:

						directory = path.dirname(directory);
						_context2.next = 4;
						break;

					case 17:
					case 'end':
						return _context2.stop();
				}
			}
		}, _callee2, _this);
	}));

	return function (_x2) {
		return _ref.apply(this, arguments);
	};
}();

module.exports.sync = function (name) {
	var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	var directory = path.resolve(options.cwd || '');

	var _path$parse2 = path.parse(directory),
	    root = _path$parse2.root;

	var paths = [].concat(name);

	var runMatcher = function runMatcher(locateOptions) {
		if (typeof name !== 'function') {
			return locatePath.sync(paths, locateOptions);
		}

		var foundPath = name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return locatePath.sync([foundPath], locateOptions);
		}

		return foundPath;
	};

	// eslint-disable-next-line no-constant-condition
	while (true) {
		var foundPath = runMatcher(Object.assign({}, options, { cwd: directory }));

		if (foundPath === stop) {
			return;
		}

		if (foundPath) {
			return path.resolve(directory, foundPath);
		}

		if (directory === root) {
			return;
		}

		directory = path.dirname(directory);
	}
};

module.exports.exists = pathExists;

module.exports.sync.exists = pathExists.sync;

module.exports.stop = stop;