'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ansiStyles = require('ansi-styles');

var _require = require('supports-color'),
    stdoutColor = _require.stdout,
    stderrColor = _require.stderr;

var _require2 = require('./util'),
    stringReplaceAll = _require2.stringReplaceAll,
    stringEncaseCRLFWithFirstIndex = _require2.stringEncaseCRLFWithFirstIndex;

var isArray = Array.isArray;

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping

var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

var styles = Object.create(null);

var applyOptions = function applyOptions(object) {
	var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	var colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

var ChalkClass = function ChalkClass(options) {
	_classCallCheck(this, ChalkClass);

	// eslint-disable-next-line no-constructor-return
	return chalkFactory(options);
};

var chalkFactory = function chalkFactory(options) {
	var chalk = {};
	applyOptions(chalk, options);

	chalk.template = function () {
		for (var _len = arguments.length, arguments_ = Array(_len), _key = 0; _key < _len; _key++) {
			arguments_[_key] = arguments[_key];
		}

		return chalkTag.apply(undefined, [chalk.template].concat(arguments_));
	};

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = function () {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

var _loop = function _loop(_ref) {
	_ref2 = _slicedToArray(_ref, 2);
	var styleName = _ref2[0];
	var style = _ref2[1];

	styles[styleName] = {
		get: function get() {
			var builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, { value: builder });
			return builder;
		}
	};
};

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
	for (var _iterator = Object.entries(ansiStyles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
		var _ref = _step.value;

		var _ref2;

		_loop(_ref);
	}
} catch (err) {
	_didIteratorError = true;
	_iteratorError = err;
} finally {
	try {
		if (!_iteratorNormalCompletion && _iterator.return) {
			_iterator.return();
		}
	} finally {
		if (_didIteratorError) {
			throw _iteratorError;
		}
	}
}

styles.visible = {
	get: function get() {
		var builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', { value: builder });
		return builder;
	}
};

var usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

var _loop2 = function _loop2(model) {
	styles[model] = {
		get: function get() {
			var level = this.level;

			return function () {
				var _ansiStyles$color$lev;

				var styler = createStyler((_ansiStyles$color$lev = ansiStyles.color[levelMapping[level]])[model].apply(_ansiStyles$color$lev, arguments), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
};

var _iteratorNormalCompletion2 = true;
var _didIteratorError2 = false;
var _iteratorError2 = undefined;

try {
	for (var _iterator2 = usedModels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
		var model = _step2.value;

		_loop2(model);
	}
} catch (err) {
	_didIteratorError2 = true;
	_iteratorError2 = err;
} finally {
	try {
		if (!_iteratorNormalCompletion2 && _iterator2.return) {
			_iterator2.return();
		}
	} finally {
		if (_didIteratorError2) {
			throw _iteratorError2;
		}
	}
}

var _loop3 = function _loop3(model) {
	var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get: function get() {
			var level = this.level;

			return function () {
				var _ansiStyles$bgColor$l;

				var styler = createStyler((_ansiStyles$bgColor$l = ansiStyles.bgColor[levelMapping[level]])[model].apply(_ansiStyles$bgColor$l, arguments), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
};

var _iteratorNormalCompletion3 = true;
var _didIteratorError3 = false;
var _iteratorError3 = undefined;

try {
	for (var _iterator3 = usedModels[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
		var model = _step3.value;

		_loop3(model);
	}
} catch (err) {
	_didIteratorError3 = true;
	_iteratorError3 = err;
} finally {
	try {
		if (!_iteratorNormalCompletion3 && _iterator3.return) {
			_iterator3.return();
		}
	} finally {
		if (_didIteratorError3) {
			throw _iteratorError3;
		}
	}
}

var proto = Object.defineProperties(function () {}, Object.assign({}, styles, {
	level: {
		enumerable: true,
		get: function get() {
			return this._generator.level;
		},
		set: function set(level) {
			this._generator.level = level;
		}
	}
}));

var createStyler = function createStyler(open, close, parent) {
	var openAll = void 0;
	var closeAll = void 0;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open: open,
		close: close,
		openAll: openAll,
		closeAll: closeAll,
		parent: parent
	};
};

var createBuilder = function createBuilder(self, _styler, _isEmpty) {
	var builder = function builder() {
		for (var _len2 = arguments.length, arguments_ = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			arguments_[_key2] = arguments[_key2];
		}

		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag.apply(undefined, [builder].concat(arguments_)));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

var applyStyle = function applyStyle(self, string) {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	var styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	var _styler2 = styler,
	    openAll = _styler2.openAll,
	    closeAll = _styler2.closeAll;

	if (string.indexOf('\x1B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	var lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

var template = void 0;
var chalkTag = function chalkTag(chalk) {
	for (var _len3 = arguments.length, strings = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		strings[_key3 - 1] = arguments[_key3];
	}

	var firstString = strings[0];


	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	var arguments_ = strings.slice(1);
	var parts = [firstString.raw[0]];

	for (var i = 1; i < firstString.length; i++) {
		parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
	}

	if (template === undefined) {
		template = require('./templates');
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

var chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 }); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;